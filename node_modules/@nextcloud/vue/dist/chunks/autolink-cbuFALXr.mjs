import { visit, SKIP } from "unist-util-visit";
import { u } from "unist-builder";
import { getBaseUrl, getRootUrl } from "@nextcloud/router";
const URL_PATTERN = /(\s|^)(https?:\/\/)([-A-Z0-9+_.]+(?::[0-9]+)?(?:\/[-A-Z0-9+&@#%?=~_|!:,.;()]*)*)(\s|$)/ig;
const URL_PATTERN_AUTOLINK = /(\s|\(|^)((https?:\/\/)([-A-Z0-9+_.]+[-A-Z0-9]+(?::[0-9]+)?(?:\/[-A-Z0-9+&@#%?=~_|!:,.;()]*)*))(?=\s|\)|$)/ig;
const NcLink = {
  name: "NcLink",
  props: {
    href: {
      type: String,
      required: true
    }
  },
  render(h) {
    return h("a", {
      attrs: {
        href: this.href,
        rel: "noopener noreferrer",
        target: "_blank",
        class: "rich-text--external-link"
      }
    }, [this.href.trim()]);
  }
};
const remarkAutolink = function({ autolink, useMarkdown, useExtendedMarkdown }) {
  return function(tree) {
    if (useExtendedMarkdown || !useMarkdown || !autolink) {
      return;
    }
    visit(tree, (node) => node.type === "text", (node, index, parent) => {
      let parsed = parseUrl(node.value);
      parsed = parsed.map((n) => {
        if (typeof n === "string") {
          return u("text", n);
        }
        return u("link", {
          url: n.props.href
        }, [u("text", n.props.href)]);
      }).filter((x) => x);
      parent.children.splice(index, 1, ...parsed.flat());
      return [SKIP, index + parsed.flat().length];
    });
  };
};
const parseUrl = (text) => {
  let match = URL_PATTERN_AUTOLINK.exec(text);
  const list = [];
  let start = 0;
  while (match !== null) {
    let href = match[2];
    let textAfter;
    let textBefore = text.substring(start, match.index + match[1].length);
    if (href[0] === " ") {
      textBefore += href[0];
      href = href.substring(1).trim();
    }
    const lastChar = href[href.length - 1];
    if (lastChar === "." || lastChar === "," || lastChar === ";" || match[0][0] === "(" && lastChar === ")") {
      href = href.substring(0, href.length - 1);
      textAfter = lastChar;
    }
    list.push(textBefore);
    list.push({ component: NcLink, props: { href } });
    if (textAfter) {
      list.push(textAfter);
    }
    start = match.index + match[0].length;
    match = URL_PATTERN_AUTOLINK.exec(text);
  }
  list.push(text.substring(start));
  const joinedText = list.map((item) => typeof item === "string" ? item : item.props.href).join("");
  if (text === joinedText) {
    return list;
  }
  console.error("Failed to reassemble the chunked text: " + text);
  return text;
};
const getRoute = (router, url) => {
  const removePrefix = (str, prefix) => str.startsWith(prefix) ? str.slice(prefix.length) : str;
  const removePrefixes = (str, ...prefixes) => prefixes.reduce((acc, prefix) => removePrefix(acc, prefix), str);
  if (!router) {
    return null;
  }
  const isAbsoluteURL = /^https?:\/\//.test(url);
  const isNonHttpLink = /^[a-z][a-z0-9+.-]*:.+/.test(url);
  if (!isAbsoluteURL && isNonHttpLink) {
    return null;
  }
  if (isAbsoluteURL && !url.startsWith(getBaseUrl())) {
    return null;
  }
  if (!isAbsoluteURL && !url.startsWith("/")) {
    return null;
  }
  const relativeUrl = isAbsoluteURL ? removePrefixes(url, getBaseUrl(), "/index.php") : url;
  const relativeRouterBase = removePrefixes(router.history.base, getRootUrl(), "/index.php");
  const potentialRouterPath = removePrefixes(relativeUrl, relativeRouterBase) || "/";
  const route = router.resolve(potentialRouterPath).route;
  if (!route.matched.length) {
    return null;
  }
  return route.fullPath;
};
export {
  URL_PATTERN as U,
  getRoute as g,
  parseUrl as p,
  remarkAutolink as r
};
//# sourceMappingURL=autolink-cbuFALXr.mjs.map
