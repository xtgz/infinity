import '../assets/NcEmojiPicker-Ca6U46T8.css';
import { Picker, Emoji, EmojiIndex } from "emoji-mart-vue-fast";
import { isFocusable } from "tabbable";
import { r as register, B as t40, C as t34, q as t14, D as t5, a as t } from "./_l10n-Dt0m9Fxw.mjs";
import { s as setCurrentSkinTone, g as getCurrentSkinTone } from "./emoji-BY_D0V5K.mjs";
import { u as useTrapStackControl } from "./useTrapStackControl-b3A_383w.mjs";
import { C as Color } from "./GenColors-S7frO84b.mjs";
import data from "emoji-mart-vue-fast/data/all.json";
import { n as normalizeComponent } from "./_plugin-vue2_normalizer-DU4iP6Vu.mjs";
import NcButton from "../Components/NcButton.mjs";
import { N as NcColorPicker } from "./NcColorPicker-C0sDksCi.mjs";
import { N as NcPopover } from "./NcPopover-kYsewfff.mjs";
import { N as NcTextField } from "./NcTextField-DRANdaIf.mjs";
register(t5, t14, t34, t40);
const _sfc_main$1 = {
  name: "CircleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$1 = function render() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon circle-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$1 = [];
var __component__$1 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$1,
  _sfc_render$1,
  _sfc_staticRenderFns$1,
  false,
  null,
  null
);
const IconCircle = __component__$1.exports;
let emojiIndex;
const i18n = {
  search: t("Search emoji"),
  notfound: t("No emoji found"),
  categories: {
    search: t("Search results"),
    recent: t("Frequently used"),
    smileys: t("Smileys & Emotion"),
    people: t("People & Body"),
    nature: t("Animals & Nature"),
    foods: t("Food & Drink"),
    activity: t("Activities"),
    places: t("Travel & Places"),
    objects: t("Objects"),
    symbols: t("Symbols"),
    flags: t("Flags"),
    custom: t("Custom")
  }
};
const skinTonePalette = [
  new Color(255, 222, 52, t("Neutral skin color")),
  new Color(228, 205, 166, t("Light skin tone")),
  new Color(250, 221, 192, t("Medium light skin tone")),
  new Color(174, 129, 87, t("Medium skin tone")),
  new Color(158, 113, 88, t("Medium dark skin tone")),
  new Color(96, 79, 69, t("Dark skin tone"))
];
const _sfc_main = {
  name: "NcEmojiPicker",
  components: {
    Emoji,
    IconCircle,
    NcButton,
    NcColorPicker,
    NcPopover,
    NcTextField,
    Picker
  },
  props: {
    /**
     * The emoji-set
     */
    activeSet: {
      type: String,
      default: "native"
    },
    /**
     * Show preview section when hovering emoji
     */
    showPreview: {
      type: Boolean,
      default: false
    },
    /**
     * Allow unselecting the selected emoji
     */
    allowUnselect: {
      type: Boolean,
      default: false
    },
    /**
     * Selected emoji to allow unselecting
     */
    selectedEmoji: {
      type: String,
      default: ""
    },
    /**
     * The fallback emoji in the preview section
     */
    previewFallbackEmoji: {
      type: String,
      default: "grinning"
    },
    /**
     * The fallback text in the preview section
     */
    previewFallbackName: {
      type: String,
      default: t("Pick an emoji")
    },
    /**
     * Whether to close the emoji picker after picking one
     */
    closeOnSelect: {
      type: Boolean,
      default: true
    },
    /**
     * Selector for the popover container
     */
    container: {
      type: [String, Object, Element, Boolean],
      default: "body"
    }
  },
  emits: [
    "select",
    "select-data",
    "unselect"
  ],
  setup() {
    if (!emojiIndex) {
      emojiIndex = new EmojiIndex(data);
    }
    return {
      // Non-reactive constants
      emojiIndex,
      skinTonePalette,
      i18n
    };
  },
  data() {
    const currentSkinTone = getCurrentSkinTone();
    return {
      /**
       * The current active color from the skin tone palette
       */
      currentColor: skinTonePalette[currentSkinTone - 1],
      /**
       * The current active skin tone
       * @type {1|2|3|4|5|6}
       */
      currentSkinTone,
      search: "",
      open: false
    };
  },
  computed: {
    native() {
      return this.activeSet === "native";
    }
  },
  created() {
    useTrapStackControl(() => this.open);
  },
  methods: {
    t,
    clearSearch() {
      this.search = "";
      this.$refs.search.focus();
    },
    /**
     * Update the current skin tone by the result of the color picker
     * @param {string} color Color set
     */
    onChangeSkinTone(color) {
      const index = this.skinTonePalette.findIndex((tone) => tone.color.toLowerCase() === color.toLowerCase());
      if (index > -1) {
        this.currentSkinTone = index + 1;
        this.currentColor = this.skinTonePalette[index];
        setCurrentSkinTone(this.currentSkinTone);
      }
    },
    select(emojiObject) {
      this.$emit("select", emojiObject.native);
      this.$emit("select-data", emojiObject);
      if (this.closeOnSelect) {
        this.open = false;
      }
    },
    unselect() {
      this.$emit("unselect");
    },
    afterShow() {
      this.$refs.search.focus();
    },
    afterHide() {
      if (!document.activeElement || this.$refs.picker.$el.contains(document.activeElement) || !isFocusable(document.activeElement)) {
        this.$refs.popover.$el.querySelector('button, [role="button"]')?.focus();
      }
    },
    /**
     * Manually handle Tab navigation skipping emoji buttons.
     * Navigation over emojis is handled by Arrow keys.
     * @param {KeyboardEvent} event - Keyboard event
     */
    handleTabNavigationSkippingEmojis(event) {
      const current = event.target;
      const focusable = Array.from(this.$refs.picker.$el.querySelectorAll("button:not(.emoji-mart-emoji), input"));
      if (!event.shiftKey) {
        const nextNode = focusable.find((node) => current.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_FOLLOWING) || focusable[0];
        nextNode.focus();
      } else {
        const prevNode = focusable.findLast((node) => current.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_PRECEDING) || focusable.at(-1);
        prevNode.focus();
      }
    },
    /**
     * Handle arrow navigation via <Picker>'s handlers with scroll bug fix
     * @param {'onArrowLeft' | 'onArrowRight' | 'onArrowDown' | 'onArrowUp'} originalHandlerName - Picker's arrow keydown handler name
     * @param {KeyboardEvent} event - Keyboard event
     */
    async callPickerArrowHandlerWithScrollFix(originalHandlerName, event) {
      this.$refs.picker[originalHandlerName](event);
      await this.$nextTick();
      const selectedEmoji = this.$refs.picker.$el.querySelector(".emoji-mart-emoji-selected");
      selectedEmoji?.scrollIntoView({
        block: "center",
        inline: "center"
      });
    }
  }
};
var _sfc_render = function render2() {
  var _vm = this, _c = _vm._self._c;
  return _c("NcPopover", _vm._g(_vm._b({ ref: "popover", attrs: {
    "shown": _vm.open,
    "container": _vm.container,
    "popup-role": "dialog",
    "focus-trap": false
    /* Handled manually to remove emoji buttons from TAB sequence */
  }, on: { "update:shown": function($event) {
    _vm.open = $event;
  }, "after-show": _vm.afterShow, "after-hide": _vm.afterHide }, scopedSlots: _vm._u([{ key: "trigger", fn: function(slotProps) {
    return [_vm._t("default", null, null, slotProps)];
  } }], null, true) }, "NcPopover", _vm.$attrs, false), _vm.$listeners), [_c("Picker", _vm._b({ ref: "picker", staticClass: "nc-emoji-picker", attrs: { "color": "var(--color-primary-element)", "data": _vm.emojiIndex, "emoji": _vm.previewFallbackEmoji, "i18n": _vm.i18n, "native": _vm.native, "emoji-size": 20, "per-line": 8, "picker-styles": { width: "320px" }, "show-preview": _vm.showPreview, "skin": _vm.currentSkinTone, "show-skin-tones": false, "title": _vm.previewFallbackName, "role": "dialog", "aria-modal": "true", "aria-label": _vm.t("Emoji picker") }, on: { "select": _vm.select }, nativeOn: { "keydown": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) return null;
    $event.preventDefault();
    return _vm.handleTabNavigationSkippingEmojis.apply(null, arguments);
  } }, scopedSlots: _vm._u([{ key: "searchTemplate", fn: function({ onSearch }) {
    return [_c("div", { staticClass: "search__wrapper" }, [_c("NcTextField", { ref: "search", staticClass: "search", attrs: { "value": _vm.search, "label": _vm.t("Search"), "label-visible": true, "placeholder": _vm.i18n.search, "trailing-button-icon": "close", "trailing-button-label": _vm.t("Clear search"), "show-trailing-button": _vm.search !== "" }, on: { "update:value": [function($event) {
      _vm.search = $event;
    }, function($event) {
      return onSearch(_vm.search);
    }], "keydown": [function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) return null;
      if ("button" in $event && $event.button !== 0) return null;
      return _vm.callPickerArrowHandlerWithScrollFix("onArrowLeft", $event);
    }, function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "right", 39, $event.key, ["Right", "ArrowRight"])) return null;
      if ("button" in $event && $event.button !== 2) return null;
      return _vm.callPickerArrowHandlerWithScrollFix("onArrowRight", $event);
    }, function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "down", 40, $event.key, ["Down", "ArrowDown"])) return null;
      return _vm.callPickerArrowHandlerWithScrollFix("onArrowDown", $event);
    }, function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "up", 38, $event.key, ["Up", "ArrowUp"])) return null;
      return _vm.callPickerArrowHandlerWithScrollFix("onArrowUp", $event);
    }, function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) return null;
      return _vm.$refs.picker.onEnter.apply(null, arguments);
    }], "trailing-button-click": function($event) {
      _vm.clearSearch();
      onSearch("");
    } } }), _c("NcColorPicker", { attrs: { "palette-only": "", "container": _vm.container, "palette": _vm.skinTonePalette, "value": _vm.currentColor.color }, on: { "update:value": _vm.onChangeSkinTone } }, [_c("NcButton", { attrs: { "aria-label": _vm.t("Skin tone"), "variant": "tertiary-no-background" }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconCircle", { style: { color: _vm.currentColor.color }, attrs: { "title": _vm.currentColor.name, "size": 20 } })];
    }, proxy: true }], null, true) })], 1)], 1)];
  } }, _vm.allowUnselect && _vm.selectedEmoji ? { key: "customCategory", fn: function() {
    return [_c("div", { staticClass: "emoji-mart-category-label" }, [_c("h3", { staticClass: "emoji-mart-category-label" }, [_vm._v(" " + _vm._s(_vm.t("Selected")) + " ")])]), _c("Emoji", { staticClass: "emoji-selected", attrs: { "data": _vm.emojiIndex, "emoji": _vm.selectedEmoji, "native": true, "size": 32 }, on: { "click": _vm.unselect } }), _c("Emoji", { staticClass: "emoji-delete", attrs: { "data": _vm.emojiIndex, "emoji": ":x:", "native": true, "size": 10 }, on: { "click": _vm.unselect } })];
  }, proxy: true } : null], null, true) }, "Picker", _vm.$attrs, false))], 1);
};
var _sfc_staticRenderFns = [];
var __component__ = /* @__PURE__ */ normalizeComponent(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  null,
  "d1a625fa"
);
const NcEmojiPicker = __component__.exports;
export {
  NcEmojiPicker as N
};
//# sourceMappingURL=NcEmojiPicker-B7hMntv4.mjs.map
