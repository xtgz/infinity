import '../assets/NcBlurHash-7aGtE-_T.css';
import { decode } from "blurhash";
import { ref, watch, nextTick } from "vue";
import { l as logger } from "./logger-D3RVzcfQ.mjs";
import { preloadImage } from "../Functions/preloadImage.mjs";
import { n as normalizeComponent } from "./_plugin-vue2_normalizer-DU4iP6Vu.mjs";
const fadeTransition = "_fadeTransition_13rtj_2";
const fadeTransitionActive = "_fadeTransitionActive_13rtj_6";
const style0 = {
  fadeTransition,
  fadeTransitionActive
};
const _sfc_main = {
  __name: "NcBlurHash",
  props: {
    /**
     * The blur hash value to use.
     */
    hash: {
      required: true,
      type: String
    },
    /**
     * This is normally not needed, but if this blur hash is not only intended
     * for decorative purpose, descriptive text should be passed for accessibility.
     */
    alt: {
      type: String,
      default: ""
    },
    /**
     * Optional an image source to load, during the load the blur hash is shown.
     * As soon as it is loaded the image will be shown instead.
     */
    src: {
      type: String,
      default: ""
    }
  },
  emits: [
    /**
     * Emitted when the image (`src`) has been loaded.
     */
    "load"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const canvas = ref();
    const imageLoaded = ref(false);
    watch(() => props.hash, drawBlurHash);
    watch(imageLoaded, () => {
      if (imageLoaded.value === false) {
        nextTick(() => drawBlurHash());
      }
    }, { immediate: true });
    watch(() => props.src, () => {
      imageLoaded.value = false;
      if (props.src) {
        preloadImage(props.src).then((success) => {
          imageLoaded.value = success;
          emit("load", success);
        });
      }
    }, { immediate: true });
    function drawBlurHash() {
      if (imageLoaded.value) {
        return;
      }
      if (!props.hash) {
        logger.error("Invalid BlurHash value");
        return;
      }
      if (canvas.value === void 0) {
        logger.error("BlurHash canvas not available");
        return;
      }
      const { height, width } = canvas.value;
      const pixels = decode(props.hash, width, height);
      const ctx = canvas.value.getContext("2d");
      if (ctx === null) {
        logger.error("Cannot create context for BlurHash canvas");
        return;
      }
      const imageData = ctx.createImageData(width, height);
      imageData.data.set(pixels);
      ctx.putImageData(imageData, 0, 0);
    }
    return { __sfc: true, props, emit, canvas, imageLoaded, drawBlurHash };
  }
};
var _sfc_render = function render() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c("Transition", { attrs: { "css": _vm.src ? void 0 : false, "enter-active-class": _vm.$style.fadeTransition, "leave-active-class": _vm.$style.fadeTransition, "enter-class": _vm.$style.fadeTransitionActive, "leave-to-class": _vm.$style.fadeTransitionActive } }, [!_setup.imageLoaded ? _c("canvas", { ref: "canvas", attrs: { "aria-hidden": _vm.alt ? null : "true", "aria-label": _vm.alt } }) : _c("img", { attrs: { "alt": _vm.alt, "src": _vm.src } })]);
};
var _sfc_staticRenderFns = [];
const __cssModules = {
  "$style": style0
};
function _sfc_injectStyles(ctx) {
  for (var key in __cssModules) {
    this[key] = __cssModules[key];
  }
}
var __component__ = /* @__PURE__ */ normalizeComponent(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  _sfc_injectStyles,
  null
);
const NcBlurHash = __component__.exports;
export {
  NcBlurHash as N
};
//# sourceMappingURL=NcBlurHash-do2wxY-0.mjs.map
