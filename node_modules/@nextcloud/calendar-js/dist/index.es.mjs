import ICAL from 'ical.js';
import { v4 } from 'uuid';

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractParser
 * @classdesc
 */
class AbstractParser {
  /**
   * @class
   *
   * @param {object=} options Object of options
   * @param {boolean=} options.extractGlobalProperties Whether or not to preserve properties from the VCALENDAR component (defaults to false)
   * @param {boolean=} options.removeRSVPForAttendees Whether or not to remove RSVP from attendees (defaults to false)
   * @param {boolean=} options.includeTimezones Whether or not to include timezones (defaults to false)
   * @param {boolean=} options.preserveMethod Whether or not to preserve the iCalendar method (defaults to false)
   * @param {boolean=} options.processFreeBusy Whether or not to process VFreeBusy components (defaults to false)
   */
  constructor(options = {}) {
    if (new.target === AbstractParser) {
      throw new TypeError('Cannot instantiate abstract class AbstractParser');
    }

    /**
     * Options for the parser
     *
     * @type {{removeRSVPForAttendees: boolean}}
     * @private
     */
    this._options = Object.assign({}, options);

    /**
     * A name extracted from the calendar-data
     *
     * @type {string | null}
     * @protected
     */
    this._name = null;

    /**
     * A color extracted from the calendar-data
     *
     * @type {string | null}
     * @protected
     */
    this._color = null;

    /**
     * Gets the url that this icalendar file can be updated from
     *
     * @type {string}
     * @protected
     */
    this._sourceURL = null;

    /**
     * Gets the update interval if this icalendar file can be updated from a source
     *
     * @type {string}
     * @protected
     */
    this._refreshInterval = null;

    /**
     * Gets the default timezone of this calendar
     *
     * @type {string}
     * @protected
     */
    this._calendarTimezone = null;

    /**
     * Error count during parsing
     *
     * @type {Array}
     * @protected
     */
    this._errors = [];
  }

  /**
   * Gets the name extracted from the calendar-data
   *
   * @return {string | null}
   */
  getName() {
    return this._name;
  }

  /**
   * Gets the color extracted from the calendar-data
   *
   * @return {string | null}
   */
  getColor() {
    return this._color;
  }

  /**
   * Gets whether this import can be converted into a webcal subscription
   *
   * @return {boolean}
   */
  offersWebcalFeed() {
    return this._sourceURL !== null;
  }

  /**
   * Gets the url pointing to the webcal source
   *
   * @return {string | null}
   */
  getSourceURL() {
    return this._sourceURL;
  }

  /**
   * Gets the recommended refresh rate to update this subscription
   *
   * @return {string | null}
   */
  getRefreshInterval() {
    return this._refreshInterval;
  }

  /**
   * Gets the default timezone of this calendar
   *
   * @return {string}
   */
  getCalendarTimezone() {
    return this._calendarTimezone;
  }

  /**
   * {String|Object} data
   *
   * @param {any} data The data to parse
   * @throws TypeError
   */
  parse(data) {
    throw new TypeError('Abstract method not implemented by subclass');
  }

  /**
   * Returns one CalendarComponent at a time
   */
  *getItemIterator() {
    // eslint-disable-line require-yield
    throw new TypeError('Abstract method not implemented by subclass');
  }

  /**
   * Get an array of all items
   *
   * @return {CalendarComponent[]}
   */
  getAllItems() {
    return Array.from(this.getItemIterator());
  }

  /**
   * Returns a boolean whether or not the parsed data contains vevents
   *
   * @return {boolean}
   */
  containsVEvents() {
    return false;
  }

  /**
   * Returns a boolean whether or not the parsed data contains vjournals
   *
   * @return {boolean}
   */
  containsVJournals() {
    return false;
  }

  /**
   * Returns a boolean whether or not the parsed data contains vtodos
   *
   * @return {boolean}
   */
  containsVTodos() {
    return false;
  }

  /**
   * Returns a boolean whether or not the parsed data contains vfreebusys
   *
   * @return {boolean}
   */
  containsVFreeBusy() {
    return false;
  }

  /**
   * Returns a boolean whether
   *
   * @return {boolean}
   */
  hasErrors() {
    return this._errors.length !== 0;
  }

  /**
   * Get a list of all errors that occurred
   *
   * @return {*[]}
   */
  getErrorList() {
    return this._errors.slice();
  }

  /**
   * Returns the number of calendar-objects in parser
   *
   * @return {number}
   */
  getItemCount() {
    return 0;
  }

  /**
   * Gets an option provided
   *
   * @param {string} name The name of the option to get
   * @param {*} defaultValue The default value to return if option not provided
   * @return {any}
   * @protected
   */
  _getOption(name, defaultValue) {
    return Object.prototype.hasOwnProperty.call(this._options, name) ? this._options[name] : defaultValue;
  }

  /**
   * Return list of supported mime types
   *
   * @static
   */
  static getMimeTypes() {
    throw new TypeError('Abstract method not implemented by subclass');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class ModificationNotAllowedError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param baseClass
 */
function lockableTrait(baseClass) {
  /**
   * @class LockableTrait
   */
  return class extends baseClass {
    /**
     * Constructor
     *
     * @param {...any} args
     */
    constructor(...args) {
      super(...args);

      /**
       * Indicator whether this value was locked for changes
       *
       * @type {boolean}
       * @private
       */
      this._mutable = true;
    }

    /**
     * Returns whether or not this object is locked
     *
     * @return {boolean}
     */
    isLocked() {
      return !this._mutable;
    }

    /**
     * Marks this object is immutable
     * locks it against further modification
     */
    lock() {
      this._mutable = false;
    }

    /**
     * Marks this object as mutable
     * allowing further modification
     */
    unlock() {
      this._mutable = true;
    }

    /**
     * Check if modifications are allowed
     *
     * @throws {ModificationNotAllowedError} if this object is locked for modification
     * @protected
     */
    _modify() {
      if (!this._mutable) {
        throw new ModificationNotAllowedError();
      }
    }

    /**
     * Check if modification of content is allowed
     *
     * @throws {ModificationNotAllowedError} if this object is locked for modification
     * @protected
     */
    _modifyContent() {
      this._modify();
    }
  };
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class ExpectedICalJSError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Turns the entire string lowercase
 *
 * @param {string} str The string to turn lowercase
 * @return {string}
 */
function lc(str) {
  return str.toLowerCase();
}

/**
 * Turns the entire string uppercase
 *
 * @param {string} str The string to turn uppercase
 * @return {string}
 */
function uc(str) {
  return str.toUpperCase();
}

/**
 * Capitalizes the string
 *
 * @param {string} str The string of which the first character will be turned uppercase
 * @return {string}
 */
function ucFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Makes sure that a string starts with a certain other string
 * This is mostly used in the attendeeProperty to assure the uri starts with mailto:
 *
 * @param {string} str The string to check for the prefix and prepend if necessary
 * @param {string} startWith The prefix to be added if necessary
 * @return {string}
 */
function startStringWith(str, startWith) {
  if (!str.startsWith(startWith)) {
    str = startWith + str;
  }
  return str;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @type {Map<string, *>}
 */
const GLOBAL_CONFIG = new Map();

/**
 * Sets a new config key
 *
 * @param {string} key The config-key to set
 * @param {*} value The value to set for given config-key
 */
function setConfig(key, value) {
  GLOBAL_CONFIG.set(key, value);
}

/**
 * gets value of a config key
 *
 * @param {string} key The config-key to get
 * @param {*} defaultValue Default value of config does not exist
 * @return {*}
 */
function getConfig(key, defaultValue) {
  return GLOBAL_CONFIG.get(key) || defaultValue;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
 * creates a new ICAL.Component object
 *
 * @param {string} componentName The name of the component to create
 * @return {ICAL.Component}
 */
function createComponent(componentName) {
  return new ICAL.Component(lc(componentName));
}

/**
 * creates a new ICAL.Property object
 *
 * @param {string} propertyName The name of the property to create
 * @return {ICAL.Property}
 */
function createProperty(propertyName) {
  return new ICAL.Property(lc(propertyName));
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param baseClass
 */
function observerTrait(baseClass) {
  /**
   * @class ObserverTrait
   */
  return class extends baseClass {
    /**
     * Constructor
     *
     * @param {...any} args
     */
    constructor(...args) {
      super(...args);

      /**
       * List of subscribers
       *
       * @type {Function[]}
       * @private
       */
      this._subscribers = [];
    }

    /**
     * Adds a new subscriber
     *
     * @param {Function} handler - Handler to be called when modification happens
     */
    subscribe(handler) {
      this._subscribers.push(handler);
    }

    /**
     * Removes a subscriber
     *
     * @param {Function} handler - Handler to be no longer called when modification happens
     */
    unsubscribe(handler) {
      const index = this._subscribers.indexOf(handler);
      if (index === -1) {
        return;
      }
      this._subscribers.splice(index, 1);
    }

    /**
     * Notify all subscribed handlers
     *
     * @param {...any} args
     * @protected
     */
    _notifySubscribers(...args) {
      for (const handler of this._subscribers) {
        handler(...args);
      }
    }
  };
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
 * @class Parameter
 * @classdesc This class represents a property parameters as defined in RFC 5545 Section 3.2
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.2
 * @url
 */
class Parameter extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {string} name The name of the parameter
   * @param {string|Array|null} value The value of the parameter
   */
  constructor(name, value = null) {
    super();

    /**
     * Name of the parameter
     *
     * @type {string}
     * @private
     */
    this._name = uc(name);

    /**
     * Value of the parameter
     *
     * @type {string|Array|null}
     * @private
     */
    this._value = value;
  }

  /**
   * Get parameter name
   *
   * @readonly
   * @return {string}
   */
  get name() {
    return this._name;
  }

  /**
   * Get parameter value
   *
   * @return {string | Array}
   */
  get value() {
    return this._value;
  }

  /**
   * Set new parameter value
   *
   * @throws {ModificationNotAllowedError} if parameter is locked for modification
   * @param {string | Array} value The new value to set
   */
  set value(value) {
    this._modifyContent();
    this._value = value;
  }

  /**
   * Gets the first value of this parameter
   *
   * @return {string | null}
   */
  getFirstValue() {
    if (!this.isMultiValue()) {
      return this.value;
    } else {
      if (this.value.length > 0) {
        return this.value[0];
      }
    }
    return null;
  }

  /**
   * Gets an iterator for all values
   */
  *getValueIterator() {
    if (this.isMultiValue()) {
      yield* this.value.slice()[Symbol.iterator]();
    } else {
      yield this.value;
    }
  }

  /**
   * Returns whether or not the value is a multivalue
   *
   * @return {boolean}
   */
  isMultiValue() {
    return Array.isArray(this._value);
  }

  /**
   * Creates a copy of this parameter
   *
   * @return {Parameter}
   */
  clone() {
    const parameter = new this.constructor(this._name);
    if (this.isMultiValue()) {
      // only copy array values, don't copy array reference
      parameter.value = this._value.slice();
    } else {
      parameter.value = this._value;
    }

    // cloned parameters are always mutable
    return parameter;
  }

  /**
   * @inheritDoc
   */
  _modifyContent() {
    super._modifyContent();
    this._notifySubscribers();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractValue
 * @classdesc BaseClass for all values
 */
class AbstractValue extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {ICAL.Binary|ICAL.Duration|ICAL.Period|ICAL.Recur|ICAL.Time|ICAL.UtcOffset} icalValue The ICAL.JS object to wrap
   */
  constructor(icalValue) {
    if (new.target === AbstractValue) {
      throw new TypeError('Cannot instantiate abstract class AbstractValue');
    }
    super();

    /**
     * Wrapped ICAL.js value
     *
     * @type {ICAL.Binary|ICAL.Duration|ICAL.Period|ICAL.Recur|ICAL.Time|ICAL.UtcOffset}
     */
    this._innerValue = icalValue;
  }

  /**
   * Gets wrapped ICAL.JS object
   *
   * @return {*}
   */
  toICALJs() {
    return this._innerValue;
  }

  /**
   * @inheritDoc
   */
  _modifyContent() {
    super._modifyContent();
    this._notifySubscribers();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class BinaryValue
 * @classdesc Wrapper for ICAL.Binary
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.1.3
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/binary.js
 */
class BinaryValue extends AbstractValue {
  /**
   * Sets the raw b64 encoded value
   *
   * @return {string}
   */
  get rawValue() {
    return this._innerValue.value;
  }

  /**
   * Gets the raw b64 encoded value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} value - The new raw value
   */
  set rawValue(value) {
    this._modifyContent();
    this._innerValue.value = value;
  }

  /**
   * Gets the decoded value
   *
   * @return {string}
   */
  get value() {
    return this._innerValue.decodeValue();
  }

  /**
   * Sets the decoded Value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param  {string} decodedValue - The new encoded value
   */
  set value(decodedValue) {
    this._modifyContent();
    this._innerValue.setEncodedValue(decodedValue);
  }

  /**
   * clones this value
   *
   * @return {BinaryValue}
   */
  clone() {
    return BinaryValue.fromRawValue(this._innerValue.value);
  }

  /**
   * Create a new BinaryValue object from an ICAL.Binary object
   *
   * @param {ICAL.Binary} icalValue - The ICAL.Binary object
   * @return {BinaryValue}
   */
  static fromICALJs(icalValue) {
    return new BinaryValue(icalValue);
  }

  /**
   * Create a new BinaryValue object from a raw b64 encoded value
   *
   * @param {string} rawValue - The raw value
   * @return {BinaryValue}
   */
  static fromRawValue(rawValue) {
    const icalBinary = new ICAL.Binary(rawValue);
    return BinaryValue.fromICALJs(icalBinary);
  }

  /**
   * Create a new BinaryValue object from decoded value
   *
   * @param {string} decodedValue - The encoded value
   * @return {BinaryValue}
   */
  static fromDecodedValue(decodedValue) {
    const icalBinary = new ICAL.Binary();
    icalBinary.setEncodedValue(decodedValue);
    return BinaryValue.fromICALJs(icalBinary);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class DurationValue
 * @classdesc Wrapper for ICAL.Duration
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.6
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/duration.js
 */
class DurationValue extends AbstractValue {
  /**
   * Gets the weeks of the stored duration-value
   *
   * @return {number}
   */
  get weeks() {
    return this._innerValue.weeks;
  }

  /**
   * Sets the weeks of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} weeks Amount of weeks
   */
  set weeks(weeks) {
    this._modifyContent();
    if (weeks < 0) {
      throw new TypeError('Weeks cannot be negative, use isNegative instead');
    }
    this._innerValue.weeks = weeks;
  }

  /**
   * Gets the days of the stored duration-value
   *
   * @return {number}
   */
  get days() {
    return this._innerValue.days;
  }

  /**
   * Sets the days of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} days Amount of days
   */
  set days(days) {
    this._modifyContent();
    if (days < 0) {
      throw new TypeError('Days cannot be negative, use isNegative instead');
    }
    this._innerValue.days = days;
  }

  /**
   * Gets the hours of the stored duration-value
   *
   * @return {number}
   */
  get hours() {
    return this._innerValue.hours;
  }

  /**
   * Sets the weeks of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} hours Amount of hours
   */
  set hours(hours) {
    this._modifyContent();
    if (hours < 0) {
      throw new TypeError('Hours cannot be negative, use isNegative instead');
    }
    this._innerValue.hours = hours;
  }

  /**
   * Gets the minutes of the stored duration-value
   *
   * @return {number}
   */
  get minutes() {
    return this._innerValue.minutes;
  }

  /**
   * Sets the minutes of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} minutes Amount of minutes
   */
  set minutes(minutes) {
    this._modifyContent();
    if (minutes < 0) {
      throw new TypeError('Minutes cannot be negative, use isNegative instead');
    }
    this._innerValue.minutes = minutes;
  }

  /**
   * Gets the seconds of the stored duration-value
   *
   * @return {number}
   */
  get seconds() {
    return this._innerValue.seconds;
  }

  /**
   * Sets the seconds of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} seconds Amount of seconds
   */
  set seconds(seconds) {
    this._modifyContent();
    if (seconds < 0) {
      throw new TypeError('Seconds cannot be negative, use isNegative instead');
    }
    this._innerValue.seconds = seconds;
  }

  /**
   * Gets the negative-indicator of the stored duration-value
   *
   * @return {boolean}
   */
  get isNegative() {
    return this._innerValue.isNegative;
  }

  /**
   * Gets the negative-indicator of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {boolean} isNegative Whether or not the duration is negative
   */
  set isNegative(isNegative) {
    this._modifyContent();
    this._innerValue.isNegative = !!isNegative;
  }

  /**
   * Gets the amount of total seconds of the stored duration-value
   *
   * @return {* | number}
   */
  get totalSeconds() {
    return this._innerValue.toSeconds();
  }

  /**
   * Sets the amount of total seconds of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} totalSeconds The total amounts of seconds to set
   */
  set totalSeconds(totalSeconds) {
    this._modifyContent();
    this._innerValue.fromSeconds(totalSeconds);
  }

  /**
   * Compares this duration to another one
   *
   * @param {DurationValue} otherDuration The duration to compare to
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compare(otherDuration) {
    return this._innerValue.compare(otherDuration.toICALJs());
  }

  /**
   * Adds the value of another duration to this one
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DurationValue} otherDuration The duration to add
   */
  addDuration(otherDuration) {
    this._modifyContent();
    this.totalSeconds += otherDuration.totalSeconds;
    this._innerValue.normalize();
  }

  /**
   * Subtract the value of another duration from this one
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DurationValue} otherDuration The duration to subtract
   */
  subtractDuration(otherDuration) {
    this._modifyContent();
    this.totalSeconds -= otherDuration.totalSeconds;
    this._innerValue.normalize();
  }

  /**
   * clones this value
   *
   * @return {DurationValue}
   */
  clone() {
    return DurationValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new DurationValue object from an ICAL.Duration object
   *
   * @param {ICAL.Duration} icalValue The ical.js duration value
   * @return {DurationValue}
   */
  static fromICALJs(icalValue) {
    return new DurationValue(icalValue);
  }

  /**
   * Create a new DurationValue object from a number of seconds
   *
   * @param {number} seconds Total amount of seconds
   * @return {DurationValue}
   */
  static fromSeconds(seconds) {
    const icalDuration = ICAL.Duration.fromSeconds(seconds);
    return new DurationValue(icalDuration);
  }

  /**
   * Create a new DurationValue object from data
   *
   * @param {object} data The destructuring object
   * @param {number=} data.weeks Number of weeks to set
   * @param {number=} data.days Number of days to set
   * @param {number=} data.hours Number of hours to set
   * @param {number=} data.minutes Number of minutes to set
   * @param {number=} data.seconds Number of seconds to set
   * @param {boolean=} data.isNegative Whether or not duration is negative
   * @return {DurationValue}
   */
  static fromData(data) {
    const icalDuration = ICAL.Duration.fromData(data);
    return new DurationValue(icalDuration);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class DateTimeValue
 * @classdesc Wrapper for ICAL.Time
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.4
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.5
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.12
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/time.js
 */
class DateTimeValue extends AbstractValue {
  /**
   * Gets the year of the stored date-time-value
   *
   * @return {number}
   */
  get year() {
    return this._innerValue.year;
  }

  /**
   * Sets the year of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} year Number of years to set
   */
  set year(year) {
    this._modifyContent();
    this._innerValue.year = year;
  }

  /**
   * Gets the month of the stored date-time-value
   *
   * @return {number}
   */
  get month() {
    return this._innerValue.month;
  }

  /**
   * Sets the month of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} month Number of months to set
   */
  set month(month) {
    this._modifyContent();
    if (month < 1 || month > 12) {
      throw new TypeError('Month out of range');
    }
    this._innerValue.month = month;
  }

  /**
   * Gets the day of the stored date-time-value
   *
   * @return {number}
   */
  get day() {
    return this._innerValue.day;
  }

  /**
   * Sets the day of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} day Number of days to set
   */
  set day(day) {
    this._modifyContent();
    if (day < 1 || day > 31) {
      throw new TypeError('Day out of range');
    }
    this._innerValue.day = day;
  }

  /**
   * Gets the hour of the stored date-time-value
   *
   * @return {number}
   */
  get hour() {
    return this._innerValue.hour;
  }

  /**
   * Sets the hour of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} hour Number of hours to set
   */
  set hour(hour) {
    this._modifyContent();
    if (hour < 0 || hour > 23) {
      throw new TypeError('Hour out of range');
    }
    this._innerValue.hour = hour;
  }

  /**
   * Gets the minute of the stored date-time-value
   *
   * @return {number}
   */
  get minute() {
    return this._innerValue.minute;
  }

  /**
   * Sets the minute of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} minute Number of minutes to set
   */
  set minute(minute) {
    this._modifyContent();
    if (minute < 0 || minute > 59) {
      throw new TypeError('Minute out of range');
    }
    this._innerValue.minute = minute;
  }

  /**
   * Gets the second of the stored date-time-value
   *
   * @return {number}
   */
  get second() {
    return this._innerValue.second;
  }

  /**
   * Sets the second of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} second Number of seconds to set
   */
  set second(second) {
    this._modifyContent();
    if (second < 0 || second > 59) {
      throw new TypeError('Second out of range');
    }
    this._innerValue.second = second;
  }

  /**
   * Gets the timezone of this date-time-value
   *
   * @return {string | null}
   */
  get timezoneId() {
    // If zone.tzid is set and it's not 'floating' nor 'UTC', then it's a proper
    // timezone that we also have a timezone id for
    if (this._innerValue.zone.tzid && this._innerValue.zone.tzid !== 'floating' && this._innerValue.zone.tzid === 'UTC') {
      return this._innerValue.zone.tzid;
    }

    // If there is a timezone set, but we didn't have a zone.tzid in the previous if,
    // this means that the tzid does not have a definition stored along it.
    // we will keep this information anyway to not lose it
    if (this._innerValue.timezone) {
      return this._innerValue.timezone;
    }

    // this is the case when it's floating / UTC
    return this._innerValue.zone.tzid || null;
  }

  /**
   * Gets whether this date-time-value is a date or date-time
   *
   * @return {boolean}
   */
  get isDate() {
    return this._innerValue.isDate;
  }

  /**
   * Sets whether this date-time-value is a date or date-time
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {boolean} isDate Whether this is a date or date-time value
   */
  set isDate(isDate) {
    this._modifyContent();
    this._innerValue.isDate = !!isDate;
    if (isDate) {
      this._innerValue.hour = 0;
      this._innerValue.minute = 0;
      this._innerValue.second = 0;
    }
  }

  /**
   * Gets the unix-time
   *
   * @return {number}
   */
  get unixTime() {
    return this._innerValue.toUnixTime();
  }

  /**
   * returns vanilla javascript date object
   *
   * @return {Date}
   */
  get jsDate() {
    return this._innerValue.toJSDate();
  }

  /**
   * Adds a duration to this date-time-value
   *
   * @param {DurationValue} duration The duration to ad
   */
  addDuration(duration) {
    this._innerValue.addDuration(duration.toICALJs());
  }

  /**
   * Subtract another date excluding timezones
   *
   * @param {DateTimeValue} other The date-time value to subtract
   * @return {DurationValue}
   */
  subtractDateWithoutTimezone(other) {
    const icalDuration = this._innerValue.subtractDate(other.toICALJs());
    return DurationValue.fromICALJs(icalDuration);
  }

  /**
   * Subtract another date, taking timezones into account
   *
   * @param {DateTimeValue} other The date-time value to subtract
   * @return {DurationValue}
   */
  subtractDateWithTimezone(other) {
    const icalDuration = this._innerValue.subtractDateTz(other.toICALJs());
    return DurationValue.fromICALJs(icalDuration);
  }

  /**
   * Compares this DateTimeValue object with another one
   *
   * @param {DateTimeValue} other The date-time to compare to
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compare(other) {
    return this._innerValue.compare(other.toICALJs());
  }

  /**
   * Compares only the date part in a given timezone
   *
   * @param {DateTimeValue} other The date-time to compare to
   * @param {Timezone} timezone The timezone to compare in
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compareDateOnlyInGivenTimezone(other, timezone) {
    return this._innerValue.compareDateOnlyTz(other.toICALJs(), timezone.toICALTimezone());
  }

  /**
   * Returns a clone of this object which was converted to a different timezone
   *
   * @param {Timezone} timezone TimezoneId to convert to
   * @return {DateTimeValue}
   */
  getInTimezone(timezone) {
    const clonedICALTime = this._innerValue.convertToZone(timezone.toICALTimezone());
    return DateTimeValue.fromICALJs(clonedICALTime);
  }

  /**
   * Get the inner ICAL.Timezone
   *
   * @return {ICAL.Timezone}
   * @package
   */
  getICALTimezone() {
    return this._innerValue.zone;
  }

  /**
   * Returns a clone of this object which was converted to a different timezone
   *
   * @param {ICAL.Timezone} timezone TimezoneId to convert to
   * @return {DateTimeValue}
   * @package
   */
  getInICALTimezone(timezone) {
    const clonedICALTime = this._innerValue.convertToZone(timezone);
    return DateTimeValue.fromICALJs(clonedICALTime);
  }

  /**
   * Returns a clone of this object which was converted to UTC
   *
   * @return {DateTimeValue}
   */
  getInUTC() {
    const clonedICALTime = this._innerValue.convertToZone(ICAL.Timezone.utcTimezone);
    return DateTimeValue.fromICALJs(clonedICALTime);
  }

  /**
   * This silently replaces the inner timezone without converting the actual time
   *
   * @param {ICAL.Timezone} timezone The timezone to replace with
   * @package
   */
  silentlyReplaceTimezone(timezone) {
    this._modify();
    this._innerValue = new ICAL.Time({
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second,
      isDate: this.isDate,
      timezone
    });
  }

  /**
   * Replaces the inner timezone without converting the actual time
   *
   * @param {Timezone} timezone The timezone to replace with
   */
  replaceTimezone(timezone) {
    this._modifyContent();
    this._innerValue = ICAL.Time.fromData({
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second,
      isDate: this.isDate
    }, timezone.toICALTimezone());
  }

  /**
   * Calculates the UTC offset of the date-time-value in its timezone
   *
   * @return {number}
   */
  utcOffset() {
    return this._innerValue.utcOffset();
  }

  /**
   * Check if this is an event with floating time
   *
   * @return {boolean}
   */
  isFloatingTime() {
    return this._innerValue.zone.tzid === 'floating';
  }

  /**
   * clones this value
   *
   * @return {DateTimeValue}
   */
  clone() {
    return DateTimeValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new DateTimeValue object from an ICAL.Time object
   *
   * @param {ICAL.Time} icalValue The ical.js Date value to initialise from
   * @return {DateTimeValue}
   */
  static fromICALJs(icalValue) {
    return new DateTimeValue(icalValue);
  }

  /**
   * Creates a new DateTimeValue object based on a vanilla javascript object
   *
   * @param {Date} jsDate The JavaScript date to initialise from
   * @param {boolean=} useUTC Whether or not to treat it as UTC
   * @return {DateTimeValue}
   */
  static fromJSDate(jsDate, useUTC = false) {
    const icalValue = ICAL.Time.fromJSDate(jsDate, useUTC);
    return DateTimeValue.fromICALJs(icalValue);
  }

  /**
   * Creates a new DateTimeValue object based on simple parameters
   *
   * @param {object} data The destructuring object
   * @param {number=} data.year Amount of years to set
   * @param {number=} data.month Amount of month to set (1-based)
   * @param {number=} data.day Amount of days to set
   * @param {number=} data.hour Amount of hours to set
   * @param {number=} data.minute Amount of minutes to set
   * @param {number=} data.second Amount of seconds to set
   * @param {boolean=} data.isDate Whether this is a date or date-time
   * @param {Timezone=} timezone The timezone of the DateTimeValue
   * @return {DateTimeValue}
   */
  static fromData(data, timezone) {
    const icalValue = ICAL.Time.fromData(data, timezone ? timezone.toICALTimezone() : undefined);
    return DateTimeValue.fromICALJs(icalValue);
  }
}
DateTimeValue.SUNDAY = ICAL.Time.SUNDAY;
DateTimeValue.MONDAY = ICAL.Time.MONDAY;
DateTimeValue.TUESDAY = ICAL.Time.TUESDAY;
DateTimeValue.WEDNESDAY = ICAL.Time.WEDNESDAY;
DateTimeValue.THURSDAY = ICAL.Time.THURSDAY;
DateTimeValue.FRIDAY = ICAL.Time.FRIDAY;
DateTimeValue.SATURDAY = ICAL.Time.SATURDAY;
DateTimeValue.DEFAULT_WEEK_START = DateTimeValue.MONDAY;

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class PeriodValue
 * @classdesc Wrapper for ICAL.Period
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.9
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/period.js
 */
class PeriodValue extends AbstractValue {
  /**
   * @inheritDoc
   */
  constructor(...args) {
    super(...args);

    /**
     * DateTimeValue object for start
     *
     * @type {DateTimeValue}
     * @private
     */
    this._start = DateTimeValue.fromICALJs(this._innerValue.start);

    /**
     * DateTimeValue object for end
     *
     * @type {DateTimeValue|null}
     * @private
     */
    this._end = null;

    /**
     * DurationValue object for duration
     *
     * @type {DurationValue|null}
     * @private
     */
    this._duration = null;
  }

  /**
   * Gets the start of the period-value
   *
   * @return {DateTimeValue}
   */
  get start() {
    return this._start;
  }

  /**
   * Sets the start of the period-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DateTimeValue} start The start of the period
   */
  set start(start) {
    this._modifyContent();
    this._start = start;
    this._innerValue.start = start.toICALJs();
  }

  /**
   * Gets the end of the period-value
   *
   * @return {DateTimeValue}
   */
  get end() {
    if (!this._end) {
      if (this._duration) {
        this._duration.lock();
        this._duration = null;
      }
      this._innerValue.end = this._innerValue.getEnd();
      this._end = DateTimeValue.fromICALJs(this._innerValue.end);
      this._innerValue.duration = null;
      if (this.isLocked()) {
        this._end.lock();
      }
    }
    return this._end;
  }

  /**
   * Sets the end of the period-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DateTimeValue} end The end of the period
   */
  set end(end) {
    this._modifyContent();
    this._innerValue.duration = null;
    this._innerValue.end = end.toICALJs();
    this._end = end;
  }

  /**
   * Gets the duration of the period-value
   * The value is automatically locked.
   * If you want to edit the value, clone it and it as new duration
   *
   * @return {DurationValue}
   */
  get duration() {
    if (!this._duration) {
      if (this._end) {
        this._end.lock();
        this._end = null;
      }
      this._innerValue.duration = this._innerValue.getDuration();
      this._duration = DurationValue.fromICALJs(this._innerValue.duration);
      this._innerValue.end = null;
      if (this.isLocked()) {
        this._duration.lock();
      }
    }
    return this._duration;
  }

  /**
   * Sets the duration of the period-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DurationValue} duration The duration to set
   */
  set duration(duration) {
    this._modifyContent();
    this._innerValue.end = null;
    this._innerValue.duration = duration.toICALJs();
    this._duration = duration;
  }

  /**
   * @inheritDoc
   */
  lock() {
    super.lock();
    this.start.lock();
    if (this._end) {
      this._end.lock();
    }
    if (this._duration) {
      this._duration.lock();
    }
  }

  /**
   * @inheritDoc
   */
  unlock() {
    super.unlock();
    this.start.unlock();
    if (this._end) {
      this._end.unlock();
    }
    if (this._duration) {
      this._duration.unlock();
    }
  }

  /**
   * clones this value
   *
   * @return {PeriodValue}
   */
  clone() {
    return PeriodValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new PeriodValue object from a ICAL.Period object
   *
   * @param {ICAL.Period} icalValue The ical.js period value to initialise from
   * @return {PeriodValue}
   */
  static fromICALJs(icalValue) {
    return new PeriodValue(icalValue);
  }

  /**
   * Create a new PeriodValue object from start and end
   *
   * @param {object} data The destructuring object
   * @param {DateTimeValue} data.start The start of the period
   * @param {DateTimeValue} data.end The end of the period
   * @return {PeriodValue}
   */
  static fromDataWithEnd(data) {
    const icalPeriod = ICAL.Period.fromData({
      start: data.start.toICALJs(),
      end: data.end.toICALJs()
    });
    return PeriodValue.fromICALJs(icalPeriod);
  }

  /**
   * Create a new PeriodValue object from start and duration
   *
   * @param {object} data The destructuring object
   * @param {DateTimeValue} data.start The start of the period
   * @param {DurationValue} data.duration The duration of the period
   * @return {PeriodValue}
   */
  static fromDataWithDuration(data) {
    const icalPeriod = ICAL.Period.fromData({
      start: data.start.toICALJs(),
      duration: data.duration.toICALJs()
    });
    return PeriodValue.fromICALJs(icalPeriod);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
const ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];

/**
 * @class RecurValue
 * @classdesc Wrapper for ICAL.Recur
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.10
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/recur.js
 */
class RecurValue extends AbstractValue {
  /**
   * Constructor
   *
   * @param {ICAL.Recur} icalValue The ical.js rrule value
   * @param {DateTimeValue?} until The Until date
   */
  constructor(icalValue, until) {
    super(icalValue);

    /**
     * DateTimeValue object for Until
     *
     * @type {DateTimeValue}
     * @private
     */
    this._until = until;
  }

  /**
   * Gets the stored interval of this recurrence rule
   *
   * @return {number}
   */
  get interval() {
    return this._innerValue.interval;
  }

  /**
   * Sets the stored interval of this recurrence rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} interval New Interval to set
   */
  set interval(interval) {
    this._modifyContent();
    this._innerValue.interval = parseInt(interval, 10);
  }

  /**
   * Gets the weekstart used to calculate the recurrence expansion
   *
   * @return {number}
   */
  get weekStart() {
    return this._innerValue.wkst;
  }

  /**
   * Sets the weekstart used to calculate the recurrence expansion
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if weekstart out of range
   * @param {number} weekStart New start of week to set
   */
  set weekStart(weekStart) {
    this._modifyContent();
    if (weekStart < DateTimeValue.SUNDAY || weekStart > DateTimeValue.SATURDAY) {
      throw new TypeError('Weekstart out of range');
    }
    this._innerValue.wkst = weekStart;
  }

  /**
   * Gets the until value if set
   * The value is automatically locked.
   * If you want to edit the value, clone it and it as new until
   *
   * @return {null|DateTimeValue}
   */
  get until() {
    if (!this._until && this._innerValue.until) {
      this._until = DateTimeValue.fromICALJs(this._innerValue.until);
    }
    return this._until;
  }

  /**
   * Sets the until value, automatically removes count
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DateTimeValue} until New until date to set
   */
  set until(until) {
    this._modifyContent();
    if (this._until) {
      this._until.lock();
    }
    this._until = until;
    this._innerValue.count = null;
    this._innerValue.until = until.toICALJs();
  }

  /**
   * Gets the count value if set
   *
   * @return {null | number}
   */
  get count() {
    return this._innerValue.count;
  }

  /**
   * Sets the count value, automatically removes until
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} count New occurrence limit to set
   */
  set count(count) {
    this._modifyContent();
    if (this._until) {
      this._until.lock();
      this._until = null;
    }
    this._innerValue.until = null;
    this._innerValue.count = parseInt(count, 10);
  }

  /**
   * Gets the frequency of the recurrence rule
   *
   * @return {string} see
   */
  get frequency() {
    return this._innerValue.freq;
  }

  /**
   * Sets the frequency of the recurrence rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if frequency is unknown
   * @param {string} freq New frequency to set
   */
  set frequency(freq) {
    this._modifyContent();
    if (!ALLOWED_FREQ.includes(freq)) {
      throw new TypeError('Unknown frequency');
    }
    this._innerValue.freq = freq;
  }

  /**
   * Modifies this recurrence-value to unset count and until
   */
  setToInfinite() {
    this._modifyContent();
    if (this._until) {
      this._until.lock();
      this._until = null;
    }
    this._innerValue.until = null;
    this._innerValue.count = null;
  }

  /**
   * Checks whether the stored rule is finite
   *
   * @return {boolean}
   */
  isFinite() {
    return this._innerValue.isFinite();
  }

  /**
   * Checks whether the recurrence rule is limited by count
   *
   * @return {boolean}
   */
  isByCount() {
    return this._innerValue.isByCount();
  }

  /**
   * Adds a part to a component to the recurrence-rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} componentName The name of the recurrence-component to add
   * @param {string | number} value The value to add
   */
  addComponent(componentName, value) {
    this._modifyContent();
    this._innerValue.addComponent(componentName, value);
  }

  /**
   * Sets / overwrites a component to the recurrence-rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} componentName The name of the component to set
   * @param {number[] | string[]} value The value to set
   */
  setComponent(componentName, value) {
    this._modifyContent();
    if (value.length === 0) {
      delete this._innerValue.parts[componentName.toUpperCase()];
    } else {
      this._innerValue.setComponent(componentName, value);
    }
  }

  /**
   * Removes all parts of a component
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} componentName The name of the component to remove
   */
  removeComponent(componentName) {
    delete this._innerValue.parts[uc(componentName)];
  }

  /**
   * Gets all parts of a component
   *
   * @param {string} componentName The name of the component to get
   * @return {Array}
   */
  getComponent(componentName) {
    return this._innerValue.getComponent(componentName);
  }

  /**
   * Checks if this recurrence rule is valid according to RFC 5545
   *
   * @return {boolean}
   */
  isRuleValid() {
    return true;
  }

  /**
   * @inheritDoc
   */
  lock() {
    super.lock();
    if (this._until) {
      this._until.lock();
    }
  }

  /**
   * @inheritDoc
   */
  unlock() {
    super.unlock();
    if (this._until) {
      this._until.unlock();
    }
  }

  /**
   * clones this value
   *
   * @return {RecurValue}
   */
  clone() {
    return RecurValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new RecurValue object from a ICAL.Recur object
   *
   * @param {ICAL.Recur} icalValue The ICAL.JS Recur value
   * @param {DateTimeValue?} until The Until date
   * @return {RecurValue}
   */
  static fromICALJs(icalValue, until = null) {
    return new RecurValue(icalValue, until);
  }

  /**
   * Create a new RecurValue object from a data object
   *
   * @param {object} data The destructuring object
   * @param {string=} data.freq FREQ part of RRULE
   * @param {number=} data.interval INTERVAL part of RRULE
   * @param {number=} data.wkst WEEKSTART part of RRULE
   * @param {DateTimeValue=} data.until UNTIL part of RRULE
   * @param {number=} data.count COUNT part of RRULE
   * @param {number[]=} data.bysecond BYSECOND part of RRULE
   * @param {number[]=} data.byminute BYMINUTE part of RRULE
   * @param {number[]=} data.byhour BYHOUR part of RRULE
   * @param {string[]=} data.byday BYDAY part of RRULE
   * @param {number[]=} data.bymonthday BYMONTHDAY part of RRULE
   * @param {number[]=} data.byyearday BYYEARDAY part of RRULE
   * @param {number[]=} data.byweekno BYWEEKNO part of RRULE
   * @param {number[]=} data.bymonth BYMONTH part of RRULE
   * @param {number[]=} data.bysetpos BYSETPOS part of RRULE
   * @return {RecurValue}
   */
  static fromData(data) {
    let until = null;
    if (data.until) {
      until = data.until;
      data.until = data.until.toICALJs();
    }
    const icalRecur = ICAL.Recur.fromData(data);
    return RecurValue.fromICALJs(icalRecur, until);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class UTCOffsetValue
 * @classdesc Wrapper for ICAL.UtcOffset
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.14
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/utc_offset.js
 */
class UTCOffsetValue extends AbstractValue {
  /**
   * Gets the hour part of the offset-value
   *
   * @return {number}
   */
  get hours() {
    return this._innerValue.hours;
  }

  /**
   * Sets the hour part of the offset-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} hours - New hours to set
   */
  set hours(hours) {
    this._modifyContent();
    this._innerValue.hours = hours;
  }

  /**
   * Gets the minute part of the offset-value
   *
   * @return {number}
   */
  get minutes() {
    return this._innerValue.minutes;
  }

  /**
   * Sets the minute part of the offset-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} minutes - New minutes to set
   */
  set minutes(minutes) {
    this._modifyContent();
    this._innerValue.minutes = minutes;
  }

  /**
   * Gets the factor
   *
   * @return {number}
   */
  get factor() {
    return this._innerValue.factor;
  }

  /**
   * Sets the factor
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if factor is neither 1 nor -1
   * @param {number} factor - New factor to set, 1 for positive, -1 for negative
   */
  set factor(factor) {
    this._modifyContent();
    if (factor !== 1 && factor !== -1) {
      throw new TypeError('Factor may only be set to 1 or -1');
    }
    this._innerValue.factor = factor;
  }

  /**
   * Gets the total amount of seconds
   *
   * @return {number}
   */
  get totalSeconds() {
    return this._innerValue.toSeconds();
  }

  /**
   * Sets the total amount of seconds
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} totalSeconds - New number of total seconds to set
   */
  set totalSeconds(totalSeconds) {
    this._modifyContent();
    this._innerValue.fromSeconds(totalSeconds);
  }

  /**
   * Compares this UTCOffset to another one
   *
   * @param {UTCOffsetValue} other - The other UTCOffsetValue to compare with
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compare(other) {
    return this._innerValue.compare(other.toICALJs());
  }

  /**
   * Clones this value
   *
   * @return {UTCOffsetValue}
   */
  clone() {
    return UTCOffsetValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new UTCOffsetValue object from a ICAL.UTCOffset object
   *
   * @param {ICAL.UtcOffset} icalValue - The ICAL.UtcOffset object to initialize this object from
   * @return {UTCOffsetValue}
   */
  static fromICALJs(icalValue) {
    return new UTCOffsetValue(icalValue);
  }

  /**
   * Create a new UTCOffsetValue object from a data object
   *
   * @param {object} data - Object with data to create UTCOffsetValue object from
   * @param {number=} data.hours - The number of hours to set
   * @param {number=} data.minutes - The number of minutes to set
   * @param {number=} data.factor - The factor to use, 1 for positive, -1 for negative
   * @return {UTCOffsetValue}
   */
  static fromData(data) {
    const icalUTCOffset = new ICAL.UtcOffset();
    icalUTCOffset.fromData(data);
    return UTCOffsetValue.fromICALJs(icalUTCOffset);
  }

  /**
   * Create a new UTCOffsetValue object from an amount of seconds
   *w
   *
   * @param {number} seconds - The total number of seconds to create the UTCOffsetValue object from
   * @return {UTCOffsetValue}
   */
  static fromSeconds(seconds) {
    const icalUTCOffset = ICAL.UtcOffset.fromSeconds(seconds);
    return UTCOffsetValue.fromICALJs(icalUTCOffset);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class UnknownICALTypeError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param {string} icaltype The icaltype to get a Value constructor for
 * @return {RecurValue|PeriodValue|BinaryValue|DurationValue|UTCOffsetValue|DateTimeValue}
 */
function getConstructorForICALType(icaltype) {
  switch (lc(icaltype)) {
    case 'binary':
      return BinaryValue;
    case 'date':
    case 'date-time':
      return DateTimeValue;
    case 'duration':
      return DurationValue;
    case 'period':
      return PeriodValue;
    case 'recur':
      return RecurValue;
    case 'utc-offset':
      return UTCOffsetValue;
    default:
      throw new UnknownICALTypeError();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class Property
 * @classdesc This class represents a property as defined in RFC 5545 Section 3.5
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.5
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/property.js
 */
class Property extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {string} name The name of the property
   * @param {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null} value The value of the property
   * @param {Parameter[] | [string][]} parameters Array of parameters
   * @param {CalendarComponent|null} root The root of the calendar-document
   * @param {AbstractComponent|null} parent The parent-element of this property
   */
  constructor(name, value = null, parameters = [], root = null, parent = null) {
    super();

    /**
     * Name of the property
     *
     * @type {string}
     * @protected
     */
    this._name = uc(name);

    /**
     * Value of the property
     *
     * @type {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
     * @protected
     */
    this._value = value;

    /**
     * List of parameters associated with this parameter
     *
     * @type {Map<string, Parameter>}
     */
    this._parameters = new Map();

    /**
     * Root node of ical document
     *
     * @type {CalendarComponent|null}
     * @protected
     */
    this._root = root;

    /**
     * Parent node
     *
     * @type {AbstractComponent|null}
     * @protected
     */
    this._parent = parent;
    this._setParametersFromConstructor(parameters);
    if (value instanceof AbstractValue) {
      value.subscribe(() => this._notifySubscribers());
    }
  }

  /**
   * Get property name
   *
   * @readonly
   * @return {string}
   */
  get name() {
    return this._name;
  }

  /**
   * Get parameter value
   *
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
   */
  get value() {
    return this._value;
  }

  /**
   * Set new parameter value
   *
   * @param {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null} value The value of the property
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  set value(value) {
    this._modifyContent();
    this._value = value;
    if (value instanceof AbstractValue) {
      value.subscribe(() => this._notifySubscribers());
    }
  }

  /**
   * Gets the root of this property
   *
   * @return {CalendarComponent|null}
   */
  get root() {
    return this._root;
  }

  /**
   * Sets the root of this property
   *
   * @param {CalendarComponent|null} root The root of the calendar-document
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  set root(root) {
    this._modify();
    this._root = root;
  }

  /**
   * Gets the direct parent element of this property
   *
   * @return {AbstractComponent}
   */
  get parent() {
    return this._parent;
  }

  /**
   * Sets the direct parent element of this property
   *
   * @param {AbstractComponent|null} parent The parent element of this property
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  set parent(parent) {
    this._modify();
    this._parent = parent;
  }

  /**
   * Gets the first value of this property
   *
   * @return {null | string | number | AbstractValue}
   */
  getFirstValue() {
    if (!this.isMultiValue()) {
      return this.value;
    } else {
      if (this.value.length > 0) {
        return this.value[0];
      }
    }
    return null;
  }

  /**
   * Gets an iterator over all values
   */
  *getValueIterator() {
    if (this.isMultiValue()) {
      yield* this.value.slice()[Symbol.iterator]();
    } else {
      yield this.value;
    }
  }

  /**
   * Adds a value to the multi-value property
   *
   * @param {string | AbstractValue} value Value to add
   */
  addValue(value) {
    if (!this.isMultiValue()) {
      throw new TypeError('This is not a multivalue property');
    }
    this._modifyContent();
    this.value.push(value);
  }

  /**
   * Checks if a value is inside this multi-value property
   *
   * @param {string | AbstractValue} value Value to check for
   * @return {boolean}
   */
  hasValue(value) {
    if (!this.isMultiValue()) {
      throw new TypeError('This is not a multivalue property');
    }
    return this.value.includes(value);
  }

  /**
   * Removes a value from this multi-value property
   *
   * @param {string | AbstractValue} value Value to remove
   */
  removeValue(value) {
    if (!this.hasValue(value)) {
      return;
    }
    this._modifyContent();
    const index = this.value.indexOf(value);
    this.value.splice(index, 1);
  }

  /**
   * Sets a parameter on this property
   *
   * @param {Parameter} parameter The parameter to set
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  setParameter(parameter) {
    this._modify();
    this._parameters.set(parameter.name, parameter);
    parameter.subscribe(() => this._notifySubscribers());
  }

  /**
   * Gets a parameter on this property by its name
   *
   * @param {string} parameterName Name of the parameter to get
   * @return {Parameter}
   */
  getParameter(parameterName) {
    return this._parameters.get(uc(parameterName));
  }

  /**
   * Gets an iterator over all available parameters
   */
  *getParametersIterator() {
    yield* this._parameters.values();
  }

  /**
   * Get first value of a parameter
   *
   * @param {string} parameterName Name of the parameter
   * @return {null | string}
   */
  getParameterFirstValue(parameterName) {
    const parameter = this.getParameter(parameterName);
    if (parameter instanceof Parameter) {
      if (parameter.isMultiValue()) {
        return parameter.value[0];
      } else {
        return parameter.value;
      }
    }
    return null;
  }

  /**
   * Returns whether a parameter exists on this property
   *
   * @param {string} parameterName Name of the parameter
   * @return {boolean}
   */
  hasParameter(parameterName) {
    return this._parameters.has(uc(parameterName));
  }

  /**
   * Deletes a parameter on this property
   *
   * @param {string} parameterName Name of the parameter
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  deleteParameter(parameterName) {
    this._modify();
    this._parameters.delete(uc(parameterName));
  }

  /**
   * update a parameter if it exists,
   * create a new one if it doesn't
   *
   * @param {string} parameterName Name of the parameter
   * @param {string|Array|null} value Value to set
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  updateParameterIfExist(parameterName, value) {
    this._modify();
    if (this.hasParameter(parameterName)) {
      const parameter = this.getParameter(parameterName);
      parameter.value = value;
    } else {
      const parameter = new Parameter(uc(parameterName), value);
      this.setParameter(parameter);
    }
  }

  /**
   * Returns whether or not the value is a multivalue
   *
   * @return {boolean}
   */
  isMultiValue() {
    return Array.isArray(this._value);
  }

  /**
   * Returns whether or not this valus is decorated
   *
   * @return {boolean}
   */
  isDecoratedValue() {
    if (this.isMultiValue()) {
      return this._value[0] instanceof AbstractValue;
    } else {
      return this._value instanceof AbstractValue;
    }
  }

  /**
   * Marks this parameter is immutable
   * locks it against further modification
   */
  lock() {
    super.lock();
    for (const parameter of this.getParametersIterator()) {
      parameter.lock();
    }
    if (this.isDecoratedValue()) {
      for (const value of this.getValueIterator()) {
        value.lock();
      }
    }
  }

  /**
   * Marks this parameter as mutable
   * allowing further modification
   */
  unlock() {
    super.unlock();
    for (const parameter of this.getParametersIterator()) {
      parameter.unlock();
    }
    if (this.isDecoratedValue()) {
      for (const value of this.getValueIterator()) {
        value.unlock();
      }
    }
  }

  /**
   * Creates a copy of this parameter
   *
   * @return {Property}
   */
  clone() {
    const parameters = [];
    for (const parameter of this.getParametersIterator()) {
      parameters.push(parameter.clone());
    }
    return new this.constructor(this.name, this._cloneValue(), parameters, this.root, this.parent);
  }

  /**
   * Copies the values of this property
   *
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
   * @protected
   */
  _cloneValue() {
    if (this.isDecoratedValue()) {
      if (this.isMultiValue()) {
        return this._value.map(val => val.clone());
      } else {
        return this._value.clone();
      }
    } else {
      if (this.isMultiValue()) {
        // only copy array values, don't copy array reference
        return this._value.slice();
      } else {
        return this._value;
      }
    }
  }

  /**
   * Sets parameters from the constructor
   *
   * @param {Parameter[] | [string][]} parameters Array of parameters to set
   * @private
   */
  _setParametersFromConstructor(parameters) {
    parameters.forEach(parameter => {
      if (!(parameter instanceof Parameter)) {
        parameter = new Parameter(parameter[0], parameter[1]);
      }
      this.setParameter(parameter);
    });
  }

  /**
   * Creates a new Component based on an ical object
   *
   * @param {ICAL.Property} icalProperty The ical.js property to initialise from
   * @param {CalendarComponent=} root The root of the calendar-document
   * @param {AbstractComponent=} parent The parent element of this property
   * @return {Property}
   */
  static fromICALJs(icalProperty, root = null, parent = null) {
    if (!(icalProperty instanceof ICAL.Property)) {
      throw new ExpectedICalJSError();
    }
    let value;
    if (icalProperty.isDecorated) {
      const constructor = getConstructorForICALType(icalProperty.getFirstValue().icaltype);
      if (icalProperty.isMultiValue) {
        value = icalProperty.getValues().map(val => constructor.fromICALJs(val));
      } else {
        value = constructor.fromICALJs(icalProperty.getFirstValue());
      }
    } else {
      if (icalProperty.isMultiValue) {
        value = icalProperty.getValues();
      } else {
        value = icalProperty.getFirstValue();
      }
    }
    const parameters = [];
    const paramNames = Object.keys(Object.assign({}, icalProperty.toJSON()[1]));
    paramNames.forEach(paramName => {
      // Timezone id is handled by DateTimeValue
      if (uc(paramName) === 'TZID') {
        return;
      }
      parameters.push([paramName, icalProperty.getParameter(paramName)]);
    });
    return new this(icalProperty.name, value, parameters, root, parent);
  }

  /**
   * Returns an ICAL.js property based on this Property
   *
   * @return {ICAL.Property}
   */
  toICALJs() {
    const icalProperty = createProperty(lc(this.name));
    if (this.isMultiValue()) {
      if (this.isDecoratedValue()) {
        icalProperty.setValues(this.value.map(val => val.toICALJs()));
      } else {
        icalProperty.setValues(this.value);
      }
    } else {
      if (this.isDecoratedValue()) {
        icalProperty.setValue(this.value.toICALJs());
      } else {
        icalProperty.setValue(this.value);
      }
    }
    for (const parameter of this.getParametersIterator()) {
      icalProperty.setParameter(lc(parameter.name), parameter.value);
    }
    const firstValue = this.getFirstValue();
    if (firstValue instanceof DateTimeValue && firstValue.timezoneId !== 'floating' && firstValue.timezoneId !== 'UTC' && !firstValue.isDate) {
      icalProperty.setParameter('tzid', firstValue.timezoneId);
    }
    return icalProperty;
  }

  /**
   * @inheritDoc
   */
  _modifyContent() {
    super._modifyContent();
    this._notifySubscribers();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AttachmentProperty
 * @classdesc This class represents an attachment property as defined in RFC 5545 Section 3.8.1.1
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.1
 */
class AttachmentProperty extends Property {
  /**
   * Gets the format-type of this attachment
   *
   * @return {string}
   */
  get formatType() {
    return this.getParameterFirstValue('FMTTYPE');
  }

  /**
   * Sets the format-type of this attachment
   *
   * @param {string} fmtType Mime-type of attachment
   */
  set formatType(fmtType) {
    this.updateParameterIfExist('FMTTYPE', fmtType);
  }

  /**
   * Gets the uri of this attachment
   *
   * @return {string | null}
   */
  get uri() {
    if (this._value instanceof BinaryValue) {
      return null;
    }
    return this._value;
  }

  /**
   * Sets the uri of this attachment
   *
   * @param {string} uri Link to attachment if applicable
   */
  set uri(uri) {
    this.value = uri;
  }

  /**
   * Gets the encoding of this attachment
   *
   * @return {string|null}
   */
  get encoding() {
    if (this._value instanceof BinaryValue) {
      return 'BASE64';
    }
    return null;
  }

  /**
   * Gets the data stored in this attachment
   *
   * @return {string | null}
   */
  get data() {
    if (this._value instanceof BinaryValue) {
      return this._value.value;
    }
    return null;
  }

  /**
   * Sets the data stored in this attachment
   *
   * @param {string} data The data of the attachment
   */
  set data(data) {
    if (this.value instanceof BinaryValue) {
      this.value.value = data;
    } else {
      this.value = BinaryValue.fromDecodedValue(data);
    }
  }

  /**
   * @inheritDoc
   */
  toICALJs() {
    const icalProperty = super.toICALJs();
    if (this._value instanceof BinaryValue && this.getParameterFirstValue('ENCODING') !== 'BASE64') {
      icalProperty.setParameter('ENCODING', 'BASE64');
    }
    return icalProperty;
  }

  /**
   * Creates a new AttachmentProperty based on data
   *
   * @param {string} data The data of the attachment
   * @param {string=} formatType The mime-type of the data
   * @return {AttachmentProperty}
   */
  static fromData(data, formatType = null) {
    const binaryValue = BinaryValue.fromDecodedValue(data);
    const property = new AttachmentProperty('ATTACH', binaryValue);
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }

  /**
   * Creates a new AttachmentProperty based on a link
   *
   * @param {string} uri The URI for the attachment
   * @param {string=} formatType The mime-type of the uri
   * @return {AttachmentProperty}
   */
  static fromLink(uri, formatType = null) {
    const property = new AttachmentProperty('ATTACH', uri);
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AttendeeProperty
 * @classdesc This class represents an attendee property as defined in RFC 5545 Section 3.8.4.1
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 */
class AttendeeProperty extends Property {
  /**
   * Returns the role of the attendee.
   *
   * @return {string}
   */
  get role() {
    const allowed = ['CHAIR', 'REQ-PARTICIPANT', 'OPT-PARTICIPANT', 'NON-PARTICIPANT'];
    const defaultValue = 'REQ-PARTICIPANT';
    if (this.hasParameter('ROLE')) {
      const value = this.getParameterFirstValue('ROLE');
      if (allowed.includes(value)) {
        return value;
      }
    }
    return defaultValue;
  }

  /**
   * Sets new role of the attendee
   *
   * @param {string} role The role of the attendee (e.g. CHAIR, REQ-PARTICIPANT)
   */
  set role(role) {
    this.updateParameterIfExist('ROLE', role);
  }

  /**
   * Returns the calendar-user-type of an attendee
   *
   * @return {string}
   */
  get userType() {
    const allowed = ['INDIVIDUAL', 'GROUP', 'RESOURCE', 'ROOM', 'UNKNOWN'];
    if (!this.hasParameter('CUTYPE')) {
      return 'INDIVIDUAL';
    } else {
      const value = this.getParameterFirstValue('CUTYPE');
      if (allowed.includes(value)) {
        return value;
      }
      return 'UNKNOWN';
    }
  }

  /**
   * Sets new calendar-user-type of attendee
   *
   * @param {string} userType The type of user (e.g. INDIVIDUAL, GROUP)
   */
  set userType(userType) {
    this.updateParameterIfExist('CUTYPE', userType);
  }

  /**
   * Returns the "Répondez s'il vous plaît" value for attendee
   *
   * @return {boolean}
   */
  get rsvp() {
    if (!this.hasParameter('RSVP')) {
      return false;
    } else {
      const value = this.getParameterFirstValue('RSVP');
      return uc(value) === 'TRUE';
    }
  }

  /**
   * Updates the "Répondez s'il vous plaît" value for attendee
   *
   * @param {boolean} rsvp Whether or not to send out an invitation
   */
  set rsvp(rsvp) {
    this.updateParameterIfExist('RSVP', rsvp ? 'TRUE' : 'FALSE');
  }

  /**
   * Returns the common-name of the attendee
   *
   * @return {string|null}
   */
  get commonName() {
    return this.getParameterFirstValue('CN');
  }

  /**
   * Sets a new common-name of the attendee
   *
   * @param {string} commonName The display name of the attendee
   */
  set commonName(commonName) {
    this.updateParameterIfExist('CN', commonName);
  }

  /**
   * Returns the participation-status of the attendee
   *
   * @return {string}
   */
  get participationStatus() {
    let vobjectType;
    if (this.parent) {
      vobjectType = this.parent.name;
    } else {
      // let's assume we are inside an event
      // if we don't know better
      vobjectType = 'VEVENT';
    }
    const allowed = {
      VEVENT: ['NEEDS-ACTION', 'ACCEPTED', 'DECLINED', 'TENTATIVE', 'DELEGATED'],
      VJOURNAL: ['NEEDS-ACTION', 'ACCEPTED', 'DECLINED'],
      VTODO: ['NEEDS-ACTION', 'ACCEPTED', 'DECLINED', 'TENTATIVE', 'DELEGATED', 'COMPLETED', 'IN-PROCESS']
    };
    if (!this.hasParameter('PARTSTAT')) {
      return 'NEEDS-ACTION';
    } else {
      const value = this.getParameterFirstValue('PARTSTAT');
      if (allowed[vobjectType].includes(value)) {
        return value;
      }
      return 'NEEDS-ACTION';
    }
  }

  /**
   * Sets a new participation-status of the attendee
   *
   * @param {string} participationStatus The participation status (e.g. ACCEPTED, DECLINED)
   */
  set participationStatus(participationStatus) {
    this.updateParameterIfExist('PARTSTAT', participationStatus);
  }

  /**
   * Gets this attendee's language
   *
   * @return {string}
   */
  get language() {
    return this.getParameterFirstValue('LANGUAGE');
  }

  /**
   * Sets this attendee's language
   * This can be used to influence the language of the invitation email
   *
   * @param {string} language The preferred language of the attendee
   */
  set language(language) {
    this.updateParameterIfExist('LANGUAGE', language);
  }

  /**
   * Gets the email of the attendee
   *
   * @return {string}
   */
  get email() {
    return this.value;
  }

  /**
   * Sets the email address of the attendee
   *
   * @param {string} email The e-email address of the attendee
   */
  set email(email) {
    this.value = startStringWith(email, 'mailto:');
  }

  /**
   * Gets the email addresses of groups the attendee is a part of
   *
   * @return {string[]|null} The email addresses of the groups
   */
  get member() {
    return this.getParameter('MEMBER')?.value ?? null;
  }

  /**
   * Sets the email addresses of groups the attendee is a part of
   *
   * @param {string[]} members The email addresses of the groups
   */
  set member(members) {
    members = members.map(member => startStringWith(member, 'mailto:'));
    this.updateParameterIfExist('MEMBER', members);
  }

  /**
   * Is this attendee the organizer?
   *
   * @return {boolean}
   */
  isOrganizer() {
    return this._name === 'ORGANIZER';
  }

  /**
   * Creates a new AttendeeProperty from name and email
   *
   * @param {string} name The display name
   * @param {string} email The email address
   * @param {boolean=} isOrganizer Whether this is the organizer or an attendee
   * @return {AttendeeProperty}
   */
  static fromNameAndEMail(name, email, isOrganizer = false) {
    const propertyName = isOrganizer ? 'ORGANIZER' : 'ATTENDEE';
    email = startStringWith(email, 'mailto:');
    return new AttendeeProperty(propertyName, email, [['CN', name]]);
  }

  /**
   * Creates a new AttendeeProperty from name, email, role, userType and rsvp
   *
   * @param {string} name The display name
   * @param {string} email The email address
   * @param {string} role The role
   * @param {string} userType The type of user
   * @param {boolean} rsvp Whether to send out an invitation
   * @param {boolean=} isOrganizer Whether this is the organizer or an attendee
   * @return {AttendeeProperty}
   */
  static fromNameEMailRoleUserTypeAndRSVP(name, email, role, userType, rsvp, isOrganizer = false) {
    const propertyName = isOrganizer ? 'ORGANIZER' : 'ATTENDEE';
    email = startStringWith(email, 'mailto:');
    return new AttendeeProperty(propertyName, email, [['CN', name], ['ROLE', role], ['CUTYPE', userType], ['RSVP', rsvp ? 'TRUE' : 'FALSE']]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
ICAL.design.icalendar.property.conference = {
  defaultType: 'uri'
};
ICAL.design.icalendar.param.feature = {
  valueType: 'cal-address',
  multiValue: ','
};

/**
 * @class ConferenceProperty
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 */
class ConferenceProperty extends Property {
  /**
   * Iterator that iterates over all supported features
   * of the conference system
   */
  *getFeatureIterator() {
    if (!this.hasParameter('FEATURE')) {
      return;
    }
    const parameter = this.getParameter('FEATURE');
    yield* parameter.getValueIterator();
  }

  /**
   * Lists all supported features of the conference system
   *
   * @return {string[]}
   */
  listAllFeatures() {
    if (!this.hasParameter('FEATURE')) {
      return [];
    }
    return this.getParameter('FEATURE').value.slice();
  }

  /**
   * Adds a supported feature to the conference system
   *
   * @param {string} featureToAdd Feature to add
   */
  addFeature(featureToAdd) {
    this._modify();
    if (!this.hasParameter('FEATURE')) {
      this.updateParameterIfExist('FEATURE', [featureToAdd]);
    } else {
      if (this.hasFeature(featureToAdd)) {
        return;
      }
      const parameter = this.getParameter('FEATURE');
      parameter.value.push(featureToAdd);
    }
  }

  /**
   * Removes a supported feature
   *
   * @param {string} feature The feature to remove
   */
  removeFeature(feature) {
    this._modify();
    if (!this.hasFeature(feature)) {
      return;
    }
    const parameter = this.getParameter('FEATURE');
    const index = parameter.value.indexOf(feature);
    parameter.value.splice(index, 1);
  }

  /**
   * Removes all supported features from this conference system
   */
  clearAllFeatures() {
    this.deleteParameter('FEATURE');
  }

  /**
   * Check if this conference system supports a feature
   *
   * @param {string} feature The feature to check
   * @return {boolean}
   */
  hasFeature(feature) {
    if (!this.hasParameter('FEATURE')) {
      return false;
    }
    const parameter = this.getParameter('FEATURE');
    if (!Array.isArray(parameter.value)) {
      return false;
    }
    return parameter.value.includes(feature);
  }

  /**
   * Gets label for the conference system
   *
   * @return {string}
   */
  get label() {
    return this.getParameterFirstValue('LABEL');
  }

  /**
   * Updates the label for the conference system
   *
   * @param {string} label The label to set
   */
  set label(label) {
    this.updateParameterIfExist('LABEL', label);
  }

  /**
   * Gets the uri for this conference system
   */
  get uri() {
    return this.value;
  }

  /**
   * Sets the uri for this conference system
   *
   * @param {string} uri The URI to set
   */
  set uri(uri) {
    this.value = uri;
  }

  /**
   * @inheritDoc
   */
  toICALJs() {
    const icalProperty = super.toICALJs();
    icalProperty.setParameter('value', 'URI');
    return icalProperty;
  }

  /**
   * Creates a new ConferenceProperty based on URI, label and features
   *
   * @param {string} uri URI of the Conference
   * @param {string=} label Label of the conference
   * @param {string[]=} features Features of the conference
   * @return {ConferenceProperty}
   */
  static fromURILabelAndFeatures(uri, label = null, features = null) {
    const property = new ConferenceProperty('CONFERENCE', uri);
    if (label) {
      property.updateParameterIfExist('label', label);
    }
    if (features) {
      property.updateParameterIfExist('feature', features);
    }
    return property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class FreeBusyProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.6
 */
class FreeBusyProperty extends Property {
  /**
   * Gets the type of this FreeBusyProperty
   *
   * @return {string}
   */
  get type() {
    const allowed = ['FREE', 'BUSY', 'BUSY-UNAVAILABLE', 'BUSY-TENTATIVE'];
    const defaultValue = 'BUSY';
    if (this.hasParameter('FBTYPE')) {
      const value = this.getParameterFirstValue('FBTYPE');
      if (allowed.includes(value)) {
        return value;
      }
    }
    return defaultValue;
  }

  /**
   * Sets the type of this FreeBusyProperty
   *
   * @param {string} type The type of information (e.g. FREE, BUSY, etc.)
   */
  set type(type) {
    this.updateParameterIfExist('FBTYPE', type);
  }

  /**
   * Creates a new FreeBusyProperty based on period and type
   *
   * @param {PeriodValue} period The period for FreeBusy Information
   * @param {string} type The type of the period
   * @return {FreeBusyProperty}
   */
  static fromPeriodAndType(period, type) {
    return new FreeBusyProperty('FREEBUSY', period, [['fbtype', type]]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class GeoProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
 */
class GeoProperty extends Property {
  /**
   * @inheritDoc
   */
  constructor(name, value = [0, 0], parameters = [], root = null, parent = null) {
    super(name, value, parameters, root, parent);
  }

  /**
   * Gets the latitude stored in this property
   *
   * @return {number}
   */
  get latitude() {
    return this._value[0];
  }

  /**
   * Sets the latitude stored in this property
   *
   * @param {string | number} lat Latitude
   */
  set latitude(lat) {
    this._modifyContent();
    if (typeof lat !== 'number') {
      lat = parseFloat(lat);
    }
    this._value[0] = lat;
  }

  /**
   * Gets the longitude stored in this property
   */
  get longitude() {
    return this._value[1];
  }

  /**
   * Sets the longitude stored in this property
   *
   * @param {string | number} long Longitude
   */
  set longitude(long) {
    this._modifyContent();
    if (typeof long !== 'number') {
      long = parseFloat(long);
    }
    this._value[1] = long;
  }

  /**
   * @inheritDoc
   *
   * TODO: this is an ugly hack right now.
   * As soon as the value is an array, we assume it's multivalue
   * but GEO is a (the one and only besides request-status) structured value and is also
   * stored inside an array.
   *
   * Calling icalProperty.setValues will throw an error
   */
  toICALJs() {
    const icalProperty = createProperty(lc(this.name));
    icalProperty.setValue(this.value);
    this._parameters.forEach(parameter => {
      icalProperty.setParameter(lc(parameter.name), parameter.value);
    });
    return icalProperty;
  }

  /**
   * Creates a new GeoProperty based on a latitude and a longitude value
   *
   * @param {number} lat Latitude
   * @param {number} long Longitude
   * @return {GeoProperty}
   */
  static fromPosition(lat, long) {
    return new GeoProperty('GEO', [lat, long]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ImageProperty
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.10
 */
class ImageProperty extends AttachmentProperty {
  /**
   * Gets the image-type
   */
  get display() {
    return this.getParameterFirstValue('DISPLAY') || 'BADGE';
  }

  /**
   * Gets the image-type
   *
   * @param {string} display The display-type image is optimized for
   */
  set display(display) {
    this.updateParameterIfExist('DISPLAY', display);
  }

  /**
   * Creates a new ImageProperty based on data
   *
   * @param {string} data The data of the image
   * @param {string=} display The display-type it's optimized for
   * @param {string=} formatType The mime-type of the image
   * @return {ImageProperty}
   */
  static fromData(data, display = null, formatType = null) {
    const binaryValue = BinaryValue.fromDecodedValue(data);
    const property = new ImageProperty('IMAGE', binaryValue);
    if (display) {
      property.display = display;
    }
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }

  /**
   * Creates a new ImageProperty based on a link
   *
   * @param {string} uri The uri of the image
   * @param {string=} display The display-type it's optimized for
   * @param {string=} formatType The mime-type of the image
   * @return {ImageProperty}
   */
  static fromLink(uri, display = null, formatType = null) {
    const property = new ImageProperty('IMAGE', uri);
    if (display) {
      property.display = display;
    }
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class RelationProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.5
 */
class RelationProperty extends Property {
  /**
   * Get's the relation-type of this related-to property
   *
   * @return {string}
   */
  get relationType() {
    const allowed = ['PARENT', 'CHILD', 'SIBLING'];
    const defaultValue = 'PARENT';
    if (!this.hasParameter('RELTYPE')) {
      return defaultValue;
    } else {
      const value = this.getParameterFirstValue('RELTYPE');
      if (allowed.includes(value)) {
        return value;
      }
      return defaultValue;
    }
  }

  /**
   * Sets a new relation type
   *
   * @param {string} relationType The type of relation (e.g. SIBLING, PARENT, etc.)
   */
  set relationType(relationType) {
    this.updateParameterIfExist('RELTYPE', relationType);
  }

  /**
   * Gets Id of related object
   *
   * @return {string}
   */
  get relatedId() {
    return this.value;
  }

  /**
   * Sets a new related id
   *
   * @param {string} relatedId The Id of the related document
   */
  set relatedId(relatedId) {
    this.value = relatedId;
  }

  /**
   * Creates a new RELATED-TO property based on a relation-type and id
   *
   * @param {string} relType The type of the relation (e.g. SIBLING, CHILD)
   * @param {string} relId The Id of the related document
   * @return {RelationProperty}
   */
  static fromRelTypeAndId(relType, relId) {
    return new RelationProperty('RELATED-TO', relId, [['RELTYPE', relType]]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class RequestStatusProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.8.3
 */
class RequestStatusProperty extends Property {
  /**
   * @inheritDoc
   */
  constructor(name, value = ['1', 'Pending'], parameters = [], root = null, parent = null) {
    super(name, value, parameters, root, parent);
  }

  /**
   * Gets the status code of the request status
   *
   * @return {number}
   */
  get statusCode() {
    return parseFloat(this.value[0]);
  }

  /**
   * Sets the status code of the request status
   *
   * @param {number} statusCode The statusCode of the request
   */
  set statusCode(statusCode) {
    this._modifyContent();
    this.value[0] = statusCode.toString();

    // This makes sure 2.0 is actually saved as 2.0, not 2
    if (statusCode === Math.floor(statusCode)) {
      this.value[0] += '.0';
    }
  }

  /**
   * Gets the status message of the request status
   *
   * @return {string}
   */
  get statusMessage() {
    return this.value[1];
  }

  /**
   * Sets the status message of the request status
   *
   * @param {string} statusMessage The message of the request
   */
  set statusMessage(statusMessage) {
    this._modifyContent();
    this.value[1] = statusMessage;
  }

  /**
   * Gets the exception data of the request status if available
   *
   * @return {null | string}
   */
  get exceptionData() {
    if (!this.value[2]) {
      return null;
    }
    return this.value[2];
  }

  /**
   * Sets the exception dtat of the request status
   *
   * @param {string} exceptionData The additional exception-data
   */
  set exceptionData(exceptionData) {
    this._modifyContent();
    this.value[2] = exceptionData;
  }

  /**
   * Check if request is pending
   *
   * @return {boolean}
   */
  isPending() {
    return this.statusCode >= 1 && this.statusCode < 2;
  }

  /**
   * Check if request was successful
   *
   * @return {boolean}
   */
  isSuccessful() {
    return this.statusCode >= 2 && this.statusCode < 3;
  }

  /**
   * Check if a client error occurred
   *
   * @return {boolean}
   */
  isClientError() {
    return this.statusCode >= 3 && this.statusCode < 4;
  }

  /**
   * Check if a scheduling error occurred
   *
   * @return {boolean}
   */
  isSchedulingError() {
    return this.statusCode >= 4 && this.statusCode < 5;
  }

  /**
   * @inheritDoc
   *
   * TODO: this is an ugly hack right now.
   * As soon as the value is an array, we assume it's multivalue
   * but REQUEST-STATUS is a (the one and only besides GEO) structured value and is also
   * stored inside an array.
   *
   * Calling icalProperty.setValues will throw an error
   */
  toICALJs() {
    const icalProperty = createProperty(lc(this.name));
    icalProperty.setValue(this.value);
    this._parameters.forEach(parameter => {
      icalProperty.setParameter(lc(parameter.name), parameter.value);
    });
    return icalProperty;
  }

  /**
   * Creates a new RequestStatusProperty from a code and a status message
   *
   * @param {number} code The status-code of the request
   * @param {string} message The message of the request
   * @return {RequestStatusProperty}
   */
  static fromCodeAndMessage(code, message) {
    return new RequestStatusProperty('REQUEST-STATUS', [code.toString(), message]);
  }
}

// All request statuses registered in RFC 5546
RequestStatusProperty.SUCCESS = [2.0, 'Success'];
RequestStatusProperty.SUCCESS_FALLBACK = [2.1, 'Success, but fallback taken on one or more property values.'];
RequestStatusProperty.SUCCESS_PROP_IGNORED = [2.2, 'Success; invalid property ignored.'];
RequestStatusProperty.SUCCESS_PROPPARAM_IGNORED = [2.3, 'Success; invalid property parameter ignored.'];
RequestStatusProperty.SUCCESS_NONSTANDARD_PROP_IGNORED = [2.4, 'Success; unknown, non-standard property ignored.'];
RequestStatusProperty.SUCCESS_NONSTANDARD_PROPPARAM_IGNORED = [2.5, 'Success; unknown, non-standard property value ignored.'];
RequestStatusProperty.SUCCESS_COMP_IGNORED = [2.6, 'Success; invalid calendar component ignored.'];
RequestStatusProperty.SUCCESS_FORWARDED = [2.7, 'Success; request forwarded to Calendar User.'];
RequestStatusProperty.SUCCESS_REPEATING_IGNORED = [2.8, 'Success; repeating event ignored. Scheduled as a single component.'];
RequestStatusProperty.SUCCESS_TRUNCATED_END = [2.9, 'Success; truncated end date time to date boundary.'];
RequestStatusProperty.SUCCESS_REPEATING_VTODO_IGNORED = [2.10, 'Success; repeating VTODO ignored.  Scheduled as a single VTODO.'];
RequestStatusProperty.SUCCESS_UNBOUND_RRULE_CLIPPED = [2.11, 'Success; unbounded RRULE clipped at some finite number of instances.'];
RequestStatusProperty.CLIENT_INVALID_PROPNAME = [3.0, 'Invalid property name.'];
RequestStatusProperty.CLIENT_INVALID_PROPVALUE = [3.1, 'Invalid property value.'];
RequestStatusProperty.CLIENT_INVALID_PROPPARAM = [3.2, 'Invalid property parameter.'];
RequestStatusProperty.CLIENT_INVALID_PROPPARAMVALUE = [3.3, 'Invalid property parameter value.'];
RequestStatusProperty.CLIENT_INVALUD_CALENDAR_COMP_SEQ = [3.4, 'Invalid calendar component sequence.'];
RequestStatusProperty.CLIENT_INVALID_DATE_TIME = [3.5, 'Invalid date or time.'];
RequestStatusProperty.CLIENT_INVALID_RRULE = [3.6, 'Invalid rule.'];
RequestStatusProperty.CLIENT_INVALID_CU = [3.7, 'Invalid Calendar User.'];
RequestStatusProperty.CLIENT_NO_AUTHORITY = [3.8, 'No authority.'];
RequestStatusProperty.CLIENT_UNSUPPORTED_VERSION = [3.9, 'Unsupported version.'];
RequestStatusProperty.CLIENT_TOO_LARGE = [3.10, 'Request entity too large.'];
RequestStatusProperty.CLIENT_REQUIRED_COMP_OR_PROP_MISSING = [3.11, 'Required component or property missing.'];
RequestStatusProperty.CLIENT_UNKNOWN_COMP_OR_PROP = [3.12, 'Unknown component or property found.'];
RequestStatusProperty.CLIENT_UNSUPPORTED_COMP_OR_PROP = [3.13, 'Unsupported component or property found.'];
RequestStatusProperty.CLIENT_UNSUPPORTED_CAPABILITY = [3.14, 'Unsupported capability.'];
RequestStatusProperty.SCHEDULING_EVENT_CONFLICT = [4.0, 'Event conflict.  Date/time is busy.'];
RequestStatusProperty.SERVER_REQUEST_NOT_SUPPORTED = [5.0, 'Request not supported.'];
RequestStatusProperty.SERVER_SERVICE_UNAVAILABLE = [5.1, 'Service unavailable.'];
RequestStatusProperty.SERVER_INVALID_CALENDAR_SERVICE = [5.2, 'Invalid calendar service.'];
RequestStatusProperty.SERVER_NO_SCHEDULING_FOR_USER = [5.3, 'No scheduling support for user.'];

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TextProperty
 * @classdesc
 */
class TextProperty extends Property {
  /**
   * Gets the alternate text
   *
   * @return {string}
   */
  get alternateText() {
    return this.getParameterFirstValue('ALTREP');
  }

  /**
   * Sets the alternate text
   *
   * @param {string} altRep The alternative text
   */
  set alternateText(altRep) {
    this.updateParameterIfExist('ALTREP', altRep);
  }

  /**
   * Gets language of this property
   *
   * @return {string}
   */
  get language() {
    return this.getParameterFirstValue('LANGUAGE');
  }

  /**
   * Sets language of this property
   *
   * @param {string} language The language of the text
   */
  set language(language) {
    this.updateParameterIfExist('LANGUAGE', language);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TriggerProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.3
 */
class TriggerProperty extends Property {
  /**
   * Gets the related parameter
   *
   * @return {string}
   */
  get related() {
    if (!this.hasParameter('RELATED')) {
      return 'START';
    }
    return this.getParameterFirstValue('RELATED');
  }

  /**
   * Sets the related parameter
   *
   * @param {string} related Either START or END
   */
  set related(related) {
    this.updateParameterIfExist('RELATED', related);
  }

  /**
   * Gets the value of this trigger
   * (If you override the setter, you also have to override the getter or
   *  it will simply be undefined)
   *
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[]}
   */
  get value() {
    return super.value;
  }

  /**
   * Set the value of this trigger
   *
   * @param {DurationValue|DateTimeValue} value The time of trigger
   */
  set value(value) {
    super.value = value;

    // If it's not a duration, remove related parameter
    if (value instanceof DateTimeValue) {
      this.deleteParameter('RELATED');
      super.value = value.getInUTC();
    }
  }

  /**
   * Gets whether this alarm trigger is relative
   *
   * @return {boolean}
   */
  isRelative() {
    return this.getFirstValue() instanceof DurationValue;
  }

  /**
   * Creates a new absolute trigger
   *
   * @param {DateTimeValue} alarmTime Time to create Trigger from
   * @return {TriggerProperty}
   */
  static fromAbsolute(alarmTime) {
    return new TriggerProperty('TRIGGER', alarmTime);
  }

  /**
   * Creates a new relative trigger
   *
   * @param {DurationValue} alarmOffset Duration to create Trigger from
   * @param {boolean=} relatedToStart Related to Start or end?
   * @return {TriggerProperty}
   */
  static fromRelativeAndRelated(alarmOffset, relatedToStart = true) {
    return new TriggerProperty('TRIGGER', alarmOffset, [['RELATED', relatedToStart ? 'START' : 'END']]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param {string} propName Name of the prop to get constructor for
 * @return {AttendeeProperty|GeoProperty|ConferenceProperty|Property|AttachmentProperty|ImageProperty|RelationProperty|RequestStatusProperty}
 */
function getConstructorForPropertyName(propName) {
  switch (uc(propName)) {
    case 'ATTACH':
      return AttachmentProperty;
    case 'ATTENDEE':
    case 'ORGANIZER':
      return AttendeeProperty;
    case 'CONFERENCE':
      return ConferenceProperty;
    case 'FREEBUSY':
      return FreeBusyProperty;
    case 'GEO':
      return GeoProperty;
    case 'IMAGE':
      return ImageProperty;
    case 'RELATED-TO':
      return RelationProperty;
    case 'REQUEST-STATUS':
      return RequestStatusProperty;
    case 'TRIGGER':
      return TriggerProperty;
    case 'COMMENT':
    case 'CONTACT':
    case 'DESCRIPTION':
    case 'LOCATION':
    case 'SUMMARY':
      return TextProperty;
    default:
      return Property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractComponent
 */
class AbstractComponent extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {string} name - Name of component
   * @param {Property[]} properties - Array of properties stored inside the component
   * @param {AbstractComponent[]} components - Array of subcomponents stored inside this component
   * @param {CalendarComponent|null} root - The root of this calendar document
   * @param {AbstractComponent|null} parent - The parent component of this element
   */
  constructor(name, properties = [], components = [], root = null, parent = null) {
    super();

    /**
     * Name of component
     *
     * @type {string}
     * @private
     */
    this._name = uc(name);

    /**
     * All properties in this component
     *
     * @type {Map<string, Property[]>}
     * @private
     */
    this._properties = new Map();

    /**
     * All subcomponents of this component
     *
     * @type {Map<string, AbstractComponent[]>}
     * @private
     */
    this._components = new Map();

    /**
     * Root node of ical document
     *
     * @type {CalendarComponent|null}
     * @private
     */
    this._root = root;

    /**
     * Parent node
     *
     * @type {AbstractComponent|null}
     * @private
     */
    this._parent = parent;
    this._setPropertiesFromConstructor(properties);
    this._setComponentsFromConstructor(components);
  }

  /**
   * Get the component's name
   *
   * @return {string}
   */
  get name() {
    return this._name;
  }

  /**
   * Gets the root of this calendar-document
   *
   * @return {CalendarComponent}
   */
  get root() {
    return this._root;
  }

  /**
   * Sets the root of this calendar-document
   *
   * @param {CalendarComponent} root The new root element
   */
  set root(root) {
    this._modify();
    this._root = root;
    for (const property of this.getPropertyIterator()) {
      property.root = root;
    }
    for (const component of this.getComponentIterator()) {
      component.root = root;
    }
  }

  /**
   * Gets the parent component
   *
   * @return {AbstractComponent}
   */
  get parent() {
    return this._parent;
  }

  /**
   * Sets the parent component
   *
   * @param {AbstractComponent} parent The new parent element
   */
  set parent(parent) {
    this._modify();
    this._parent = parent;
  }

  /**
   * Gets the first property that matches the given propertyName
   *
   * @param {string} propertyName Name of the property to get
   * @return {Property|null}
   */
  getFirstProperty(propertyName) {
    if (!this._properties.has(uc(propertyName))) {
      return null;
    }
    return this._properties.get(uc(propertyName))[0];
  }

  /**
   * Gets the first value of the first property matching that name
   *
   * @param {string} propertyName Name of the property to get first value of
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
   */
  getFirstPropertyFirstValue(propertyName) {
    const property = this.getFirstProperty(propertyName);
    if (!property) {
      return null;
    }
    return property.getFirstValue();
  }

  /**
   * update a property if it exists,
   * create a new one if it doesn't
   *
   * @param {string} propertyName Name of the property to update / create
   * @param {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null} value The value to set
   */
  updatePropertyWithValue(propertyName, value) {
    this._modify();
    const property = this.getFirstProperty(propertyName);
    if (property) {
      property.value = value;
    } else {
      const constructor = getConstructorForPropertyName(propertyName);
      const newProperty = new constructor(propertyName, value, [], this, this.root);
      this.addProperty(newProperty);
    }
  }

  /**
   * Returns iterator for all properties of a given propertyName
   * or if no propertyName was given over all available properties
   *
   * @param {string=} propertyName Name of the property to get an iterator for
   */
  *getPropertyIterator(propertyName = null) {
    if (propertyName) {
      if (!this.hasProperty(propertyName)) {
        return;
      }

      // this._properties.get() returns an array
      // [Symbol.iterator]() creates an iterator from that array
      yield* this._properties.get(uc(propertyName)).slice()[Symbol.iterator]();
    } else {
      for (const key of this._properties.keys()) {
        yield* this.getPropertyIterator(key);
      }
    }
  }

  /**
   * Get all properties by name that match the given LANG parameter
   *
   * @param {string} propertyName The name of the property
   * @param {string | null} lang The lang to query
   * @private
   */
  *_getAllOfPropertyByLang(propertyName, lang) {
    for (const property of this.getPropertyIterator(propertyName)) {
      // getParameterFirstValue will return null if language not set, so no language parameter will match lang=null
      if (property.getParameterFirstValue('LANGUAGE') === lang) {
        yield property;
      }
    }
  }

  /**
   * Get the first property by name that matches the given LANG parameter
   *
   * @param {string} propertyName The name of the property
   * @param {string | null} lang The lang to query
   * @return {Property|null}
   * @private
   */
  _getFirstOfPropertyByLang(propertyName, lang) {
    const iterator = this._getAllOfPropertyByLang(propertyName, lang);
    return iterator.next().value || null;
  }

  /**
   * Adds a property
   *
   * @param {Property} property The property to add
   * @return {boolean}
   */
  addProperty(property) {
    this._modify();
    property.root = this.root;
    property.parent = this;
    if (this._properties.has(property.name)) {
      const arr = this._properties.get(property.name);
      if (arr.indexOf(property) !== -1) {
        // If the property is already part of this component,
        // return false to indicate an error
        return false;
      }
      arr.push(property);
    } else {
      this._properties.set(property.name, [property]);
    }
    property.subscribe(() => this._notifySubscribers());
    return true;
  }

  /**
   * Checks if this component has a property of the given name
   *
   * @param {string} propertyName The name of the property
   * @return {boolean}
   */
  hasProperty(propertyName) {
    return this._properties.has(uc(propertyName));
  }

  /**
   * Removes the given property from this component
   *
   * @param {Property} property The property to delete
   * @return {boolean}
   */
  deleteProperty(property) {
    this._modify();
    if (!this._properties.has(property.name)) {
      return false;
    }
    const arr = this._properties.get(property.name);
    const index = arr.indexOf(property);
    if (index === -1) {
      return false;
    }
    if (index !== -1 && arr.length === 1) {
      // If this is the last property of the given name,
      // remove the entire array from _properties
      // This is required for hasProperty to work properly
      this._properties.delete(property.name);
    } else {
      arr.splice(index, 1);
    }
    return true;
  }

  /**
   * Removes all properties of a given name
   *
   * @param {string} propertyName The name of the property
   * @return {boolean}
   */
  deleteAllProperties(propertyName) {
    this._modify();
    return this._properties.delete(uc(propertyName));
  }

  /**
   * Gets the first component of a given name
   *
   * @param {string} componentName The name of the component
   * @return {AbstractComponent|null}
   */
  getFirstComponent(componentName) {
    if (!this.hasComponent(componentName)) {
      return null;
    }
    return this._components.get(uc(componentName))[0];
  }

  /**
   * Returns iterator for all components of a given componentName
   * or if no componentName was given over all available components
   *
   * @param {string=} componentName The name of the component
   */
  *getComponentIterator(componentName) {
    if (componentName) {
      if (!this.hasComponent(componentName)) {
        return;
      }

      // this._components.get() returns an array
      // [Symbol.iterator]() creates an iterator from that array
      yield* this._components.get(uc(componentName)).slice()[Symbol.iterator]();
    } else {
      for (const key of this._components.keys()) {
        yield* this.getComponentIterator(key);
      }
    }
  }

  /**
   * Adds a new component to this component
   *
   * @param {AbstractComponent} component The component to add
   * @return {boolean}
   */
  addComponent(component) {
    this._modify();
    component.root = this.root;
    component.parent = this;
    if (this._components.has(component.name)) {
      const arr = this._components.get(component.name);
      if (arr.indexOf(component) !== -1) {
        // If the property is already part of this component,
        // return false to indicate an error
        return false;
      }
      arr.push(component);
    } else {
      this._components.set(component.name, [component]);
    }
    component.subscribe(() => this._notifySubscribers());
    return true;
  }

  /**
   * Checks if this component has a component of the given name
   *
   * @param {string} componentName The name of the component
   * @return {boolean}
   */
  hasComponent(componentName) {
    return this._components.has(uc(componentName));
  }

  /**
   * Removes the given component from this component
   *
   * @param {AbstractComponent} component The component to delete
   * @return {boolean}
   */
  deleteComponent(component) {
    this._modify();
    if (!this._components.has(component.name)) {
      return false;
    }
    const arr = this._components.get(component.name);
    const index = arr.indexOf(component);
    if (index === -1) {
      return false;
    }
    if (index !== -1 && arr.length === 1) {
      // If this is the last component of the given name,
      // remove the entire array from _components
      // This is required for hasComponent to work properly
      this._components.delete(component.name);
    } else {
      arr.splice(index, 1);
    }
    return true;
  }

  /**
   * Removes all components of a given name
   *
   * @param {string} componentName The name of the component
   * @return {boolean}
   */
  deleteAllComponents(componentName) {
    this._modify();
    return this._components.delete(uc(componentName));
  }

  /**
   * Marks this parameter is immutable
   * locks it against further modification
   */
  lock() {
    super.lock();
    for (const property of this.getPropertyIterator()) {
      property.lock();
    }
    for (const component of this.getComponentIterator()) {
      component.lock();
    }
  }

  /**
   * Marks this parameter as mutable
   * allowing further modification
   */
  unlock() {
    super.unlock();
    for (const property of this.getPropertyIterator()) {
      property.unlock();
    }
    for (const component of this.getComponentIterator()) {
      component.unlock();
    }
  }

  /**
   * Creates a copy of this parameter
   *
   * @return {AbstractComponent}
   */
  clone() {
    const properties = [];
    for (const property of this.getPropertyIterator()) {
      properties.push(property.clone());
    }
    const components = [];
    for (const component of this.getComponentIterator()) {
      components.push(component.clone());
    }
    return new this.constructor(this.name, properties, components, this.root, this.parent);
  }

  /**
   * Adds properties from constructor to this._properties
   *
   * @param {Property[]} properties Array of properties
   * @private
   */
  _setPropertiesFromConstructor(properties) {
    for (let property of properties) {
      if (Array.isArray(property)) {
        const constructor = getConstructorForPropertyName(property[0]);
        property = new constructor(property[0], property[1]);
      }
      this.addProperty(property);
    }
  }

  /**
   * Adds components from constructor to this._components
   *
   * @param {AbstractComponent[]} components Array of components
   * @private
   */
  _setComponentsFromConstructor(components) {
    for (const component of components) {
      this.addComponent(component);
    }
  }

  /**
   * Creates a new Component based on an ical object
   *
   * @param {ICAL.Component} icalValue The ical.js component to initialise from
   * @param {CalendarComponent=} root The root of the Calendar Document
   * @param {AbstractComponent=} parent The parent element of this component
   * @return {AbstractComponent}
   */
  static fromICALJs(icalValue, root = null, parent = null) {
    if (!(icalValue instanceof ICAL.Component)) {
      throw new ExpectedICalJSError();
    }
    const name = icalValue.name;
    const newComponent = new this(name, [], [], root, parent);
    for (const icalProp of icalValue.getAllProperties()) {
      const constructor = getConstructorForPropertyName(icalProp.name);
      const property = constructor.fromICALJs(icalProp, root, newComponent);
      newComponent.addProperty(property);
    }
    for (const icalComp of icalValue.getAllSubcomponents()) {
      const constructor = this._getConstructorForComponentName(icalComp.name);
      const component = constructor.fromICALJs(icalComp, root, newComponent);
      newComponent.addComponent(component);
    }
    return newComponent;
  }

  /**
   * Gets a constructor for a give component name
   *
   * @param {string} componentName The name of the component
   * @return {AbstractComponent}
   * @protected
   */
  static _getConstructorForComponentName(componentName) {
    return AbstractComponent;
  }

  /**
   * turns this Component into an ICAL.js component
   *
   * @return {ICAL.Component}
   */
  toICALJs() {
    const component = createComponent(lc(this.name));
    for (const prop of this.getPropertyIterator()) {
      component.addProperty(prop.toICALJs());
    }
    for (const comp of this.getComponentIterator()) {
      component.addSubcomponent(comp.toICALJs());
    }
    return component;
  }
}

/**
 * Advertise properties that may at most occur once
 *
 * Properties, which may at most occur once, get a simple getter and setter
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising properties
 * @param {boolean} advertiseValueOnly Whether to advertise the value only or the entire property
 */
function advertiseSingleOccurrenceProperty(prototype, options, advertiseValueOnly = true) {
  options = getDefaultOncePropConfig(options);
  Object.defineProperty(prototype, options.name, {
    get() {
      const value = this.getFirstPropertyFirstValue(options.iCalendarName);
      if (!value) {
        return options.defaultValue;
      } else {
        if (Array.isArray(options.allowedValues) && !options.allowedValues.includes(value)) {
          return options.unknownValue;
        }
        return value;
      }
    },
    set(value) {
      this._modify();
      if (value === null) {
        this.deleteAllProperties(options.iCalendarName);
        return;
      }
      if (Array.isArray(options.allowedValues) && !options.allowedValues.includes(value)) {
        throw new TypeError('Illegal value');
      }
      this.updatePropertyWithValue(options.iCalendarName, value);
    }
  });
}

/**
 * Advertise properties that may occur more than once
 *
 * Properties, which may occur more than once, won't get simple getter / setter,
 * but rather a more advanced set of get{name}Iterator, get{name}List, add{name},
 * remove{name} and clearAll{name} methods
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising properties
 */
function advertiseMultipleOccurrenceProperty(prototype, options) {
  options = getDefaultMultiplePropConfig(options);
  prototype['get' + ucFirst(options.name) + 'Iterator'] = function* () {
    yield* this.getPropertyIterator(options.iCalendarName);
  };
  prototype['get' + ucFirst(options.name) + 'List'] = function () {
    return Array.from(this['get' + ucFirst(options.name) + 'Iterator']());
  };
  prototype['remove' + ucFirst(options.name)] = function (property) {
    this.deleteProperty(property);
  };
  prototype['clearAll' + ucFirst(options.pluralName)] = function () {
    this.deleteAllProperties(options.iCalendarName);
  };
}

/**
 * advertises a multi-value string property enabling simple access by language
 * This is used for:
 * - CATEGORIES
 * - RESOURCES
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising properties
 */
function advertiseMultiValueStringPropertySeparatedByLang(prototype, options) {
  options = getDefaultMultiplePropConfig(options);
  prototype['get' + ucFirst(options.name) + 'Iterator'] = function* (lang = null) {
    for (const property of this._getAllOfPropertyByLang(options.iCalendarName, lang)) {
      yield* property.getValueIterator();
    }
  };
  prototype['get' + ucFirst(options.name) + 'List'] = function (lang = null) {
    return Array.from(this['get' + ucFirst(options.name) + 'Iterator'](lang));
  };
  prototype['add' + ucFirst(options.name)] = function (value, lang = null) {
    const property = this._getFirstOfPropertyByLang(options.iCalendarName, lang);
    if (property) {
      property.addValue(value);
    } else {
      const newProperty = new Property(options.iCalendarName, [value]);
      if (lang) {
        const languageParameter = new Parameter('LANGUAGE', lang);
        newProperty.setParameter(languageParameter);
      }
      this.addProperty(newProperty);
    }
  };
  prototype['remove' + ucFirst(options.name)] = function (value, lang = null) {
    for (const property of this._getAllOfPropertyByLang(options.iCalendarName, lang)) {
      if (property.isMultiValue() && property.hasValue(value)) {
        if (property.value.length === 1) {
          this.deleteProperty(property);
          return true;
        }
        property.removeValue(value);
        return true;
      }
    }
    return false;
  };
  prototype['clearAll' + ucFirst(options.pluralName)] = function (lang = null) {
    for (const property of this._getAllOfPropertyByLang(options.iCalendarName, lang)) {
      this.deleteProperty(property);
    }
  };
}

/**
 * advertise a component
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising components
 */
function advertiseComponent(prototype, options) {
  options = getDefaultMultipleCompConfig(options);
  prototype['get' + ucFirst(options.name) + 'Iterator'] = function* () {
    yield* this.getComponentIterator(options.iCalendarName);
  };
  prototype['get' + ucFirst(options.name) + 'List'] = function () {
    return Array.from(this['get' + ucFirst(options.name) + 'Iterator']());
  };
  prototype['remove' + ucFirst(options.name)] = function (component) {
    this.deleteComponent(component);
  };
  prototype['clearAll' + ucFirst(options.pluralName)] = function () {
    this.deleteAllComponents(options.iCalendarName);
  };
}

/**
 * Fill up the options object for advertiseProperty
 *
 * @param {object | string} options The options object
 * @param {string} options.name Advertised name of the property
 * @param {string=} options.iCalendarName The iCalendar name of the property
 * @param {string[]=} options.allowedValues A list of allowed values
 * @param {string | number=} options.defaultValue The default value if unset
 * @param {string | number=} options.unknownValue The fallback value if unknown value
 * @return {object}
 */
function getDefaultOncePropConfig(options) {
  if (typeof options === 'string') {
    options = {
      name: options
    };
  }
  return Object.assign({}, {
    iCalendarName: uc(options.name),
    pluralName: options.name + 's',
    allowedValues: null,
    defaultValue: null,
    unknownValue: null
  }, options);
}

/**
 * Fill up the options object for advertiseProperty
 *
 * @param {object | string} options The options object
 * @param {string} options.name Advertised name of property
 * @param {string=} options.iCalendarName The iCalendar name of the property
 * @param {boolean=} options.customAddMethod Whether or not to use a custom add method
 * @return {object}
 */
function getDefaultMultiplePropConfig(options) {
  if (typeof options === 'string') {
    options = {
      name: options
    };
  }
  return Object.assign({}, {
    iCalendarName: uc(options.name),
    pluralName: options.name + 's'
  }, options);
}

/**
 * Fill up the options object for advertiseComponent
 *
 * @param {object | string} options Options destructuring object
 * @param {string} options.name Advertised name of component
 * @param {string=} options.iCalendarName The iCalendar name of the component
 * @param {boolean=} options.customAddMethod Whether or not to use a custom add method
 * @return {object}
 */
function getDefaultMultipleCompConfig(options) {
  if (typeof options === 'string') {
    options = {
      name: options
    };
  }
  return Object.assign({}, {
    iCalendarName: 'V' + uc(options.name),
    pluralName: options.name + 's'
  }, options);
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets a new DateObject set to now
 *
 * @return {Date}
 */
function dateFactory() {
  return new Date();
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class RecurringWithoutDtStartError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class RecurrenceHelper
 * @classdesc
 *
 * TODO: This needs caching
 */
class RecurrenceManager {
  /**
   * Constructor
   *
   * @param {AbstractRecurringComponent} masterItem The master-item of the recurrence-set
   */
  constructor(masterItem) {
    /**
     *
     * @type {AbstractRecurringComponent}
     * @private
     */
    this._masterItem = masterItem;

    /**
     * Set of Recurrence exception items
     *
     * Number is the unix time representation of the recurrence ID
     *
     * @type {Map<number, AbstractRecurringComponent>}
     * @private
     */
    this._recurrenceExceptionItems = new Map();

    /**
     * A sorted index of recurrence ids with range
     *
     * @type {number[]}
     * @private
     */
    this._rangeRecurrenceExceptionItemsIndex = [];

    /**
     * Cached difference of dtstart and recurrenceId for recurrence exceptions with range
     *
     * @type {Map<number, DurationValue>}
     * @private
     */
    this._rangeRecurrenceExceptionItemsDiffCache = new Map();

    /**
     * Set of Recurrence exception items that have a RANGE of THISANDFUTURE
     *
     * Number is the unix time representation of the recurrence ID
     *
     * @type {Map<number, AbstractRecurringComponent>}
     * @private
     */
    this._rangeRecurrenceExceptionItems = new Map();
  }

  /**
   *
   * @return {AbstractRecurringComponent}
   */
  get masterItem() {
    return this._masterItem;
  }

  /**
   *
   * @param {AbstractRecurringComponent} masterItem The master-item of the recurrence-set
   */
  set masterItem(masterItem) {
    this._masterItem = masterItem;
  }

  /**
   * Gets an iterator over all registered recurrence exceptions of this calendar-document
   */
  *getRecurrenceExceptionIterator() {
    yield* this._recurrenceExceptionItems.values();
  }

  /**
   * Gets a list of all registered recurrence-exceptions of this calendar-document
   *
   * @return {AbstractRecurringComponent[]}
   */
  getRecurrenceExceptionList() {
    return Array.from(this.getRecurrenceExceptionIterator());
  }

  /**
   * Checks if there is a recurrence Exception for a given recurrenceId
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to check
   * @return {boolean}
   */
  hasRecurrenceExceptionForId(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof ICAL.Time) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    return this._recurrenceExceptionItems.has(recurrenceId);
  }

  /**
   * Gets the recurrence exception for a given recurrence Id
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to get
   * @return {AbstractRecurringComponent|null}
   */
  getRecurrenceException(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof ICAL.Time) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    return this._recurrenceExceptionItems.get(recurrenceId) || null;
  }

  /**
   * Check if there is a recurrence-exception with a range for a given recurrence-id
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to check
   * @return {boolean}
   */
  hasRangeRecurrenceExceptionForId(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof ICAL.Time) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    if (this._rangeRecurrenceExceptionItemsIndex.length === 0) {
      return false;
    }
    return this._rangeRecurrenceExceptionItemsIndex[0] < recurrenceId;
  }

  /**
   * Get recurrence-exception with range that's affecting the given recurrence-id
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to get
   * @return {AbstractRecurringComponent|null}
   */
  getRangeRecurrenceExceptionForId(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof ICAL.Time) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    const index = ICAL.helpers.binsearchInsert(this._rangeRecurrenceExceptionItemsIndex, recurrenceId, (a, b) => a - b);
    if (index === 0) {
      return null;
    }
    const key = this._rangeRecurrenceExceptionItemsIndex[index - 1];
    return this._rangeRecurrenceExceptionItems.get(key);
  }

  /**
   * Gets the difference between recurrence-id and start
   * Mostly needed to handle recurrence-exceptions with range
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to get
   * @return {DurationValue|null}
   */
  getRangeRecurrenceExceptionDiff(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof ICAL.Time) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    if (this._rangeRecurrenceExceptionItemsDiffCache.has(recurrenceId)) {
      return this._rangeRecurrenceExceptionItemsDiffCache.get(recurrenceId);
    }
    const recurrenceException = this.getRangeRecurrenceExceptionForId(recurrenceId);
    if (!recurrenceException) {
      return null;
    }
    const originalRecurrenceId = recurrenceException.recurrenceId;
    const originalModifiedStart = recurrenceException.startDate;
    const difference = originalModifiedStart.subtractDateWithTimezone(originalRecurrenceId);
    difference.lock();
    this._rangeRecurrenceExceptionItemsDiffCache.set(recurrenceId, difference);
    return difference;
  }

  /**
   * Adds a new recurrence-exception to this calendar-document
   *
   * @param {AbstractRecurringComponent} recurrenceExceptionItem The recurrence-exception-item to relate to recurrence-set
   */
  relateRecurrenceException(recurrenceExceptionItem) {
    this._modify();
    const key = this._getRecurrenceIdKey(recurrenceExceptionItem);
    this._recurrenceExceptionItems.set(key, recurrenceExceptionItem);
    if (recurrenceExceptionItem.modifiesFuture()) {
      this._rangeRecurrenceExceptionItems.set(key, recurrenceExceptionItem);
      const index = ICAL.helpers.binsearchInsert(this._rangeRecurrenceExceptionItemsIndex, key, (a, b) => a - b);
      this._rangeRecurrenceExceptionItemsIndex.splice(index, 0, key);
    }
    recurrenceExceptionItem.recurrenceManager = this;
  }

  /**
   * Removes a recurrence exception by the item itself
   *
   * @param {AbstractRecurringComponent} recurrenceExceptionItem The recurrence-exception remove
   */
  removeRecurrenceException(recurrenceExceptionItem) {
    const key = this._getRecurrenceIdKey(recurrenceExceptionItem);
    this.removeRecurrenceExceptionByRecurrenceId(key);
  }

  /**
   * Removes a recurrence exception by it's unix-time
   *
   * @param {number} recurrenceId The recurrence-exception to remove
   */
  removeRecurrenceExceptionByRecurrenceId(recurrenceId) {
    this._modify();
    this._recurrenceExceptionItems.delete(recurrenceId);
    this._rangeRecurrenceExceptionItems.delete(recurrenceId);
    this._rangeRecurrenceExceptionItemsDiffCache.delete(recurrenceId);
    const index = this._rangeRecurrenceExceptionItemsIndex.indexOf(recurrenceId);
    if (index !== -1) {
      this._rangeRecurrenceExceptionItemsIndex.splice(index, 1);
    }
  }

  /**
   *
   * @param {AbstractRecurringComponent} recurrenceExceptionItem Object to get key from
   * @return {number}
   * @private
   */
  _getRecurrenceIdKey(recurrenceExceptionItem) {
    return recurrenceExceptionItem.recurrenceId.unixTime;
  }

  /**
   * Gets an iterator over all recurrence rules
   */
  *getRecurrenceRuleIterator() {
    for (const property of this._masterItem.getPropertyIterator('RRULE')) {
      yield property.getFirstValue();
    }
  }

  /**
   * Gets a list of all recurrence rules
   *
   * @return {RecurValue[]}
   */
  getRecurrenceRuleList() {
    return Array.from(this.getRecurrenceRuleIterator());
  }

  /**
   * Adds a new recurrence rule
   *
   * @param {RecurValue} recurrenceRule The RRULE to add
   */
  addRecurrenceRule(recurrenceRule) {
    this._modify();
    this.resetCache();
    const property = new Property('RRULE', recurrenceRule);
    this._masterItem.addProperty(property);
  }

  /**
   * Removes a recurrence rule
   *
   * @param {RecurValue} recurrenceRule The RRULE to remove
   */
  removeRecurrenceRule(recurrenceRule) {
    this._modify();
    this.resetCache();
    for (const property of this._masterItem.getPropertyIterator('RRULE')) {
      if (property.getFirstValue() === recurrenceRule) {
        this._masterItem.deleteProperty(property);
      }
    }
  }

  /**
   * Removes all recurrence rules
   */
  clearAllRecurrenceRules() {
    this._modify();
    this.resetCache();
    this._masterItem.deleteAllProperties('RRULE');
  }

  /**
   * Gets an iterator over all recurrence
   *
   * @param {boolean} isNegative Whether or not to get EXDATES
   * @param {string} valueType Limit type of EXDATES
   */
  *getRecurrenceDateIterator(isNegative = false, valueType = null) {
    for (const property of this._getPropertiesForRecurrenceDate(isNegative, valueType)) {
      yield* property.getValueIterator();
    }
  }

  /**
   *
   * @param {boolean} isNegative Whether or not to get EXDATES
   * @param {string} valueType Limit type of EXDATES
   * @return {(DateTimeValue|PeriodValue)[]}
   */
  listAllRecurrenceDates(isNegative = false, valueType = null) {
    return Array.from(this.getRecurrenceDateIterator(isNegative, valueType));
  }

  /**
   * This adds a new recurrence-date value.
   * It automatically adds it to the first property of the same value-type
   * or creates a new one if necessary
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue|PeriodValue} value EXDATE to add
   */
  addRecurrenceDate(isNegative = false, value) {
    this._modify();
    this.resetCache();

    // Only add DateTime Value if its of the same timezone
    let timezoneId = null;
    if (value instanceof DateTimeValue && !value.isDate) {
      timezoneId = value.timezoneId;
    }
    const valueType = this._getValueTypeByValue(value);
    const iterator = this._getPropertiesForRecurrenceDate(isNegative, valueType, timezoneId);
    const first = iterator.next.value;
    if (first instanceof Property) {
      const propertyValue = first.value;
      propertyValue.push(value);
      this.masterItem.markPropertyAsDirty(isNegative ? 'EXDATE' : 'RDATE');
    } else {
      const propertyName = this._getPropertyNameByIsNegative(isNegative);
      const property = new Property(propertyName, value);
      this._masterItem.addProperty(property);
    }
  }

  /**
   * Checks if a recurrenceID is an RDATE or EXDATE
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue} recurrenceId Recurrence-Id to check
   * @return {boolean}
   */
  hasRecurrenceDate(isNegative = false, recurrenceId) {
    for (let value of this.getRecurrenceDateIterator(isNegative)) {
      if (value instanceof PeriodValue) {
        value = value.start;
      }
      if (value.compare(recurrenceId) === 0) {
        return true;
      }
    }
    return false;
  }

  /**
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue} recurrenceId Recurrence-Id to get
   * @return {null|DateTimeValue|PeriodValue}
   */
  getRecurrenceDate(isNegative = false, recurrenceId) {
    for (const value of this.getRecurrenceDateIterator(isNegative)) {
      let valueToCheck = value;
      if (valueToCheck instanceof PeriodValue) {
        valueToCheck = valueToCheck.start;
      }
      if (valueToCheck.compare(recurrenceId) === 0) {
        return value;
      }
    }
    return null;
  }

  /**
   * This deletes a recurrence-date value from this recurrence-set
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue|PeriodValue} value The EXDATE/RDATE to remove
   */
  removeRecurrenceDate(isNegative = false, value) {
    this._modify();
    this.resetCache();
    const valueType = this._getValueTypeByValue(value);
    for (const property of this._getPropertiesForRecurrenceDate(isNegative, valueType)) {
      for (const valueToCheck of property.getValueIterator()) {
        if (value === valueToCheck) {
          const allValues = property.value;
          if (allValues.length === 1) {
            this.masterItem.deleteProperty(property);
            continue;
          }
          const index = allValues.indexOf(value);
          allValues.splice(index, 1);
          this.masterItem.markPropertyAsDirty(isNegative ? 'EXDATE' : 'RDATE');
        }
      }
    }
  }

  /**
   * Clears all recurrence-date information
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {string} valueType The type of RDATEs/EXDATEs to remove
   */
  clearAllRecurrenceDates(isNegative = false, valueType = null) {
    this._modify();
    this.resetCache();
    for (const property of this._getPropertiesForRecurrenceDate(isNegative, valueType)) {
      this._masterItem.deleteProperty(property);
    }
  }

  /**
   * Gets the property name for recurrence dates based on the isNegative boolean
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @return {string}
   * @private
   */
  _getPropertyNameByIsNegative(isNegative) {
    return isNegative ? 'EXDATE' : 'RDATE';
  }

  /**
   * Gets the value type based on the provided value
   *
   * @param {PeriodValue|DateTimeValue} value The value to get type of property from
   * @return {string}
   * @private
   */
  _getValueTypeByValue(value) {
    if (value instanceof PeriodValue) {
      return 'PERIOD';
    } else if (value.isDate) {
      return 'DATE';
    } else {
      return 'DATETIME';
    }
  }

  /**
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {string | null} valueType The type of values to get
   * @param {ICAL.Timezone=} timezoneId Filter by timezone
   * @private
   */
  *_getPropertiesForRecurrenceDate(isNegative, valueType, timezoneId = null) {
    const propertyName = this._getPropertyNameByIsNegative(isNegative);
    for (const property of this._masterItem.getPropertyIterator(propertyName)) {
      if (valueType === null) {
        yield property;
      } else if (uc(valueType) === 'PERIOD' && property.getFirstValue() instanceof PeriodValue) {
        yield property;
      } else if (uc(valueType) === 'DATE' && property.getFirstValue().isDate) {
        yield property;
      } else if (uc(valueType) === 'DATETIME' && !property.getFirstValue().isDate) {
        if (timezoneId === null || property.getFirstValue().timezoneId === timezoneId) {
          yield property;
        }
      }
    }
  }

  /**
   * Checks if the entire set of recurrence rules is finite
   *
   * @return {boolean}
   */
  isFinite() {
    return this.getRecurrenceRuleList().every(rule => rule.isFinite());
  }

  /**
   * @return {boolean}
   */
  isEmptyRecurrenceSet() {
    return this._getRecurExpansionObject().next() === undefined;
  }

  /**
   * Gets the occurrence at the exact given recurrenceId
   *
   * @param {DateTimeValue} recurrenceId RecurrenceId to get
   * @return {AbstractRecurringComponent|null}
   */
  getOccurrenceAtExactly(recurrenceId) {
    if (!this.masterItem.isRecurring()) {
      if (this.masterItem.getReferenceRecurrenceId().compare(recurrenceId) === 0) {
        return this.masterItem;
      }
      return null;
    }
    const iterator = this._getRecurExpansionObject();
    const icalRecurrenceId = recurrenceId.toICALJs();
    let next;
    while (next = iterator.next()) {
      if (next.compare(icalRecurrenceId) === 0) {
        // It's a match 🔥
        return this._getOccurrenceAtRecurrenceId(DateTimeValue.fromICALJs(next));
      }
      if (next.compare(icalRecurrenceId) === 1) {
        // We hit an occurrence in the future, return null
        return null;
      }
    }
    return null;
  }

  /**
   * Gets the closest occurrence to the given recurrenceId.
   * That's either the closest in the future, or in case the
   * recurrence-set ends before recurrenceId, the last one
   *
   * This function works solely on the basis of recurrence-ids.
   * It ignores the actual date of recurrence-exceptions.
   * Ideally we should fix it and provide a similar implementation
   * like getAllOccurrencesBetweenIterator, but for now it's the
   * accepted behavior.
   *
   * @param {DateTimeValue} recurrenceId RecurrenceId to get
   * @return {AbstractRecurringComponent}
   */
  getClosestOccurrence(recurrenceId) {
    if (!this.masterItem.isRecurring()) {
      return this.masterItem;
    }
    const iterator = this._getRecurExpansionObject();
    recurrenceId = recurrenceId.toICALJs();
    let previous = null;
    let next;
    while (next = iterator.next()) {
      if (next.compare(recurrenceId) === -1) {
        previous = next;
      } else {
        // This is the case when it's either equal or in the future
        const dateTimeValue = DateTimeValue.fromICALJs(next);
        return this._getOccurrenceAtRecurrenceId(dateTimeValue);
      }
    }
    const dateTimeValue = DateTimeValue.fromICALJs(previous);
    return this._getOccurrenceAtRecurrenceId(dateTimeValue);
  }

  /**
   * Counts all occurrences in the given time-range.
   * This function works solely on the basis of recurrence-ids.
   * Start and end are inclusive.
   *
   * @param {DateTimeValue} queriedTimeRangeStart Start of time-range
   * @param {DateTimeValue} queriedTimeRangeEnd End of time-range
   * @return {number} Count of occurrences in the given time-range
   */
  countAllOccurrencesBetween(queriedTimeRangeStart, queriedTimeRangeEnd) {
    if (!this.masterItem.isRecurring()) {
      if (typeof this.masterItem.isInTimeFrame === 'function' && !this.masterItem.isInTimeFrame(queriedTimeRangeStart, queriedTimeRangeEnd)) {
        return 0;
      }
      return 1;
    }
    const iterator = this._getRecurExpansionObject();
    const queriedICALJsTimeRangeStart = queriedTimeRangeStart.toICALJs();
    const queriedICALJsTimeRangeEnd = queriedTimeRangeEnd.toICALJs();
    let count = 0;
    let next;
    while (next = iterator.next()) {
      if (next.compare(queriedICALJsTimeRangeStart) === -1) {
        continue;
      }
      if (next.compare(queriedICALJsTimeRangeEnd) === 1) {
        break;
      }
      count += 1;
    }
    return count;
  }

  /**
   * Get all occurrences between start and end
   * Start and End are inclusive
   *
   * @param {DateTimeValue} queriedTimeRangeStart Start of time-range
   * @param {DateTimeValue} queriedTimeRangeEnd End of time-range
   */
  *getAllOccurrencesBetweenIterator(queriedTimeRangeStart, queriedTimeRangeEnd) {
    if (!this.masterItem.isRecurring()) {
      if (typeof this.masterItem.isInTimeFrame !== 'function') {
        yield this.masterItem;
      }
      if (this.masterItem.isInTimeFrame(queriedTimeRangeStart, queriedTimeRangeEnd)) {
        yield this.masterItem;
      }
      return;
    }
    const iterator = this._getRecurExpansionObject();
    const queriedICALJsTimeRangeStart = queriedTimeRangeStart.toICALJs();
    const queriedICALJsTimeRangeEnd = queriedTimeRangeEnd.toICALJs();
    const recurrenceIdKeys = Array.from(this._recurrenceExceptionItems.keys());
    const maximumRecurrenceId = Math.max.apply(Math, recurrenceIdKeys);
    let next;
    while (next = iterator.next()) {
      // We have to get the real occurrence to resolve RECURRENCE-IDs
      const dateTimeValue = DateTimeValue.fromICALJs(next);
      const occurrence = this._getOccurrenceAtRecurrenceId(dateTimeValue);

      // Check what type of recurrence object we are dealing with
      // Depending on that, the time to compare to changes
      // If we are dealing events, we have to compare to the end-date
      // If we are dealing with tasks, we will have to compare to the due-date
      // etc.
      // For now we are only implementing events, other components will come later
      let compareDate = null;
      switch (uc(occurrence.name)) {
        case 'VEVENT':
        case 'VTODO':
          compareDate = occurrence.endDate.toICALJs();
          break;
        case 'VJOURNAL':
        default:
          compareDate = next;
          break;
      }

      // If the date we are comparing to is before our time-range,
      // we don't want to yield this event
      if (compareDate.compare(queriedICALJsTimeRangeStart) === -1) {
        continue;
      }

      // If we have an object that is:
      // 1. either
      // 1.1 - no recurrence exception
      //     or
      // 1.2 - a recurrence-exception that modifies the future
      // and
      // 2. starts after the queried time-range ends, then we stop expanding
      const startDate = occurrence.startDate.toICALJs();
      if ((!occurrence.isRecurrenceException() || occurrence.modifiesFuture()) && startDate.compare(queriedICALJsTimeRangeEnd) === 1) {
        // Just break if there are no recurrence-exceptions
        if (this._recurrenceExceptionItems.size === 0) {
          break;
        }

        // Keep iterating until our currently checked recurrenceId
        // is bigger than the maximum recurrence-id that we have.
        if (next.toUnixTime() > maximumRecurrenceId) {
          break;
        } else {
          continue;
        }
      }
      if (typeof occurrence.isInTimeFrame !== 'function') {
        yield occurrence;
      }
      if (occurrence.isInTimeFrame(queriedTimeRangeStart, queriedTimeRangeEnd)) {
        yield occurrence;
      }
    }
  }

  /**
   * Get all occurrences between start and end
   *
   * @param {DateTimeValue} start Start of time-range
   * @param {DateTimeValue} end End of time-range
   * @return {(*|null)[]}
   */
  getAllOccurrencesBetween(start, end) {
    return Array.from(this.getAllOccurrencesBetweenIterator(start, end));
  }

  /**
   * Update the UID of all components in the recurrence set
   *
   * @param {string} newUID The new UID of the calendar-document
   */
  updateUID(newUID) {
    this._masterItem.updatePropertyWithValue('UID', newUID);
    for (const recurrenceExceptionItem of this.getRecurrenceExceptionIterator()) {
      recurrenceExceptionItem.updatePropertyWithValue('UID', newUID);
    }
  }

  /**
   * Updates the recurrence-information accordingly,
   * whenever the start-date of the master-item changes
   *
   * @param {DateTimeValue} newStartDate The new start-date
   * @param {DateTimeValue} oldStartDate The old start-date
   */
  updateStartDateOfMasterItem(newStartDate, oldStartDate) {
    const difference = newStartDate.subtractDateWithTimezone(oldStartDate);

    // update EXDATE
    for (const exdate of this.getRecurrenceDateIterator(true)) {
      // If this EXDATE matches an RDATE, don't update, because we don't update RDATEs
      if (this.hasRecurrenceDate(false, exdate)) {
        continue;
      }

      // EXDATE are always either DATE or DATETIME,
      // no need to check for PERIOD
      exdate.addDuration(difference);
    }
    for (const recurrenceException of this.getRecurrenceExceptionIterator()) {
      // We don't edit RDATES, so don't update recurrence-ids if they
      // are based on an RDATE
      if (this.hasRecurrenceDate(false, recurrenceException.recurrenceId)) {
        continue;
      }
      this.removeRecurrenceException(recurrenceException);
      recurrenceException.recurrenceId.addDuration(difference);
      this.relateRecurrenceException(recurrenceException);
    }

    // update UNTIL of recurrence-rules
    for (const rrule of this.getRecurrenceRuleIterator()) {
      if (rrule.until) {
        rrule.until.addDuration(difference);
      }
    }
  }

  /**
   * Gets an object for the given recurrenceId
   * It does not verify that the given recurrenceId
   * is actually a valid recurrence of this calendar-document
   *
   * @param {DateTimeValue} recurrenceId Recurrence-Id to get
   * @return {AbstractRecurringComponent}
   * @private
   */
  _getOccurrenceAtRecurrenceId(recurrenceId) {
    if (this.hasRecurrenceExceptionForId(recurrenceId)) {
      const recurrenceException = this.getRecurrenceException(recurrenceId);
      if (!recurrenceException.canCreateRecurrenceExceptions()) {
        return recurrenceException;
      }
      return recurrenceException.forkItem(recurrenceId);
    } else if (this.hasRangeRecurrenceExceptionForId(recurrenceId)) {
      const rangeRecurrenceException = this.getRangeRecurrenceExceptionForId(recurrenceId);
      const difference = this.getRangeRecurrenceExceptionDiff(recurrenceId);
      return rangeRecurrenceException.forkItem(recurrenceId, difference);
    } else if (recurrenceId.compare(this._masterItem.startDate) === 0) {
      if (!this._masterItem.canCreateRecurrenceExceptions()) {
        return this._masterItem;
      }
      return this._masterItem.forkItem(recurrenceId);
    } else {
      return this._masterItem.forkItem(recurrenceId);
    }
  }

  /**
   * Resets the internal recur-expansion object.
   * This is necessary after each modification of the
   * recurrence-information
   */
  resetCache() {
    // TODO - implement me
  }

  /**
   * Gets a new ICAL.RecurExpansion object
   *
   * Inspired by how ICAL.JS RecurExpansion
   * serialises and unserialises its state
   *
   * @return {ICAL.RecurExpansion}
   * @private
   */
  _getRecurExpansionObject() {
    if (this._masterItem.startDate === null) {
      throw new RecurringWithoutDtStartError();
    }
    const dtstart = this._masterItem.startDate.toICALJs();
    let last = dtstart.clone();
    const ruleIterators = [];
    let ruleDateInc;
    const ruleDates = [];
    let ruleDate = null;
    const exDates = [];
    const complete = false;
    for (const ruleValue of this.getRecurrenceRuleIterator()) {
      ruleIterators.push(ruleValue.toICALJs().iterator(dtstart));
      ruleIterators[ruleIterators.length - 1].next();
    }
    for (let rDateValue of this.getRecurrenceDateIterator()) {
      if (rDateValue instanceof PeriodValue) {
        rDateValue = rDateValue.start;
      }
      rDateValue = rDateValue.toICALJs();
      const index = ICAL.helpers.binsearchInsert(ruleDates, rDateValue, (a, b) => a.compare(b));
      ruleDates.splice(index, 0, rDateValue);
    }

    // Is the first RDATE prior to our current DTSTART?
    if (ruleDates.length > 0 && ruleDates[0].compare(dtstart) === -1) {
      ruleDateInc = 0;
      last = ruleDates[0].clone();
    } else {
      ruleDateInc = ICAL.helpers.binsearchInsert(ruleDates, dtstart, (a, b) => a.compare(b));
      ruleDate = exDates[ruleDateInc];
    }
    for (let exDateValue of this.getRecurrenceDateIterator(true)) {
      exDateValue = exDateValue.toICALJs();
      const index = ICAL.helpers.binsearchInsert(exDates, exDateValue, (a, b) => a.compare(b));
      exDates.splice(index, 0, exDateValue);
    }
    const exDateInc = ICAL.helpers.binsearchInsert(exDates, dtstart, (a, b) => a.compare(b));
    const exDate = exDates[exDateInc];
    return new ICAL.RecurExpansion({
      dtstart,
      last,
      ruleIterators,
      ruleDateInc,
      exDateInc,
      ruleDates,
      ruleDate,
      exDates,
      exDate,
      complete
    });
  }

  /**
   * @private
   */
  _modify() {
    if (this._masterItem.isLocked()) {
      throw new ModificationNotAllowedError();
    }
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
 * @class Timezone
 */
class Timezone {
  /**
   * Constructor
   *
   * @param {string | ICAL.Timezone | ICAL.Component} timezoneId Id of the timezone
   * @param {string?} ics The iCalendar timezone definition
   */
  constructor(timezoneId, ics) {
    /**
     * Id of the timezone, used before initialising
     *
     * @type {string}
     * @private
     */
    this._timezoneId = null;

    /**
     * ICS representation of the timezone, used before initialising
     *
     * @type {string}
     * @private
     */
    this._ics = null;

    /**
     * @type {ICAL.Timezone|null}
     */
    this._innerValue = null;

    /**
     *
     * @type {boolean}
     * @private
     */
    this._initialized = false;

    // If the first parameter is already
    // an instance of ICAL.Timezone,
    // skip lazy loading
    if (timezoneId instanceof ICAL.Timezone) {
      this._innerValue = timezoneId;
      this._initialized = true;
    } else if (timezoneId instanceof ICAL.Component) {
      this._innerValue = new ICAL.Timezone(timezoneId);
      this._initialized = true;
    } else {
      this._timezoneId = timezoneId;
      this._ics = ics;
    }
  }

  /**
   * Gets the timezone id
   *
   * @return {string}
   */
  get timezoneId() {
    if (this._initialized) {
      return this._innerValue.tzid;
    }
    return this._timezoneId;
  }

  /**
   * Gets the UTC Offset for a given date in this timezone
   *
   * @param {number} year Year of the date
   * @param {number} month Month of the date (1-based)
   * @param {number} day Day of the date
   * @param {number} hour Hour of the date
   * @param {number} minute Minute of the date
   * @param {number} second Second of the date
   * @return {number}
   */
  offsetForArray(year, month, day, hour, minute, second) {
    this._initialize();
    const time = new ICAL.Time({
      year,
      month,
      day,
      hour,
      minute,
      second,
      isDate: false
    });
    return this._innerValue.utcOffset(time);
  }

  /**
   * Converts a timestamp to an array of year, month, day, hour, minute, second.
   *
   * @param {number} ms Timestamp in milliseconds
   * @return {number[]}
   */
  timestampToArray(ms) {
    this._initialize();

    // just create a dummy object because fromUnixTime is not exposed on ICAL.Time
    const time = ICAL.Time.fromData({
      year: 1970,
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0
    });
    time.fromUnixTime(Math.floor(ms / 1000));
    const local = time.convertToZone(this._innerValue);
    return [local.year, local.month,
    // THIS is 1-based !
    local.day, local.hour, local.minute, local.second];
  }

  /**
   * Returns
   *
   * @return {ICAL.Timezone}
   */
  toICALTimezone() {
    this._initialize();
    return this._innerValue;
  }

  /**
   * Returns the corresponding ICAL.
   *
   * @return {ICAL.Component}
   */
  toICALJs() {
    this._initialize();
    return this._innerValue.component;
  }

  /**
   * Initialises the inner ICAL.Timezone component
   *
   * @private
   */
  _initialize() {
    if (!this._initialized) {
      const jCal = ICAL.parse(this._ics);
      const icalComp = new ICAL.Component(jCal);
      this._innerValue = new ICAL.Timezone(icalComp);
      this._initialized = true;
    }
  }
}
Timezone.utc = new Timezone(ICAL.Timezone.utcTimezone);
Timezone.floating = new Timezone(ICAL.Timezone.localTimezone);

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AlarmComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.6
 */
class AlarmComponent extends AbstractComponent {
  /**
   * Adds a new attendee based on their name and email-address
   *
   * @param {string} name - Name of the attendee
   * @param {string} email - E-Mail address of the attendee
   * @return {boolean}
   */
  addAttendeeFromNameAndEMail(name, email) {
    const attendeeProperty = AttendeeProperty.fromNameAndEMail(name, email);
    return this.addProperty(attendeeProperty);
  }

  /**
   * Gets the trigger property
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.3
   *
   * @return {TriggerProperty}
   */
  get trigger() {
    return this.getFirstProperty('TRIGGER');
  }

  /**
   * Sets an absolute alarm
   *
   * @param {DateTimeValue} alarmTime - Absolute time for the trigger
   */
  setTriggerFromAbsolute(alarmTime) {
    const triggerProperty = TriggerProperty.fromAbsolute(alarmTime);
    this.deleteAllProperties('TRIGGER');
    this.addProperty(triggerProperty);
  }

  /**
   * Sets a relative trigger
   *
   * @param {DurationValue} alarmOffset - Relative time of the trigger, either related to start or end
   * @param {boolean=} relatedToStart - Related to Start or end?
   */
  setTriggerFromRelative(alarmOffset, relatedToStart = true) {
    const triggerProperty = TriggerProperty.fromRelativeAndRelated(alarmOffset, relatedToStart);
    this.deleteAllProperties('TRIGGER');
    this.addProperty(triggerProperty);
  }
}

/**
 * Action to be taken when this Alarm is due
 * Possible values:
 * - AUDIO
 * - DISPLAY
 * - EMAIL
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.1
 *
 * @name AlarmComponent#action
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'action');

/**
 * Description for this alarm
 * Can only be used in combination with action DISPLAY and EMAIL
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name AlarmComponent#description
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'description');

/**
 * Summary for this alarm
 * Can only be used in combination with action EMAIL
 * Will be used as the EMAIL's subject
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.12
 *
 * @name AlarmComponent#summary
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'summary');

/**
 * The duration specifies the delay period between repeated alarms.
 * This property must be specified along with the repeat property
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.5
 *
 * @name AlarmComponent#duration
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'duration');

/**
 * The number of times an alarm should be repeated.
 * This property must be specified along with the duration property
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.2
 *
 * @name AlarmComponent#repeat
 * @type {number}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'repeat');

/**
 * This attachment points to a sound file, can only be used in combination
 * with ACTION AUDIO
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.1
 *
 * @name AlarmComponent#attachment
 * @type {AttachmentProperty}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, {
  name: 'attachment',
  iCalendarName: 'ATTACH'
});

/**
 * Get an iterator over all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#getAttendeeIterator
 * @function
 * @return {IterableIterator<AttendeeProperty>}
 */

/**
 * Get a list of all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#getAttendeeList
 * @function
 * @return {AttendeeProperty[]}
 */

/**
 * Adds a new attendee to this alarm-component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#addAttendee
 * @function
 * @param {AttendeeProperty} attendee - The attendee object to add
 */

/**
 * Removes an attendee from this alarm-component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#removeAttendee
 * @function
 * @param {AttendeeProperty} attendee - The attendee object to remove
 */

/**
 * Removes all attendees from this alarm-component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#clearAllAttendees
 * @function
 */
advertiseMultipleOccurrenceProperty(AlarmComponent.prototype, 'attendee');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets the constructor for a component name
 * This will only return a constructor for components,
 * that can be nested inside other ones
 *
 * @param {string} compName - Component name to get default constructor for
 * @return {AlarmComponent|AbstractComponent}
 */
function getConstructorForComponentName$1(compName) {
  switch (uc(compName)) {
    case 'VALARM':
      return AlarmComponent;
    default:
      return AbstractComponent;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractRecurringComponent
 * @classdesc AbstractRecurringComponent is the basis for
 * EventComponent, JournalComponent and TodoComponent.
 *
 * It contains all the logic for recurrence-expansion and
 * recurrence-management plus all management for all
 * properties and all subcomponents that the three
 * components mentioned before have in common
 */
class AbstractRecurringComponent extends AbstractComponent {
  /**
   * @inheritDoc
   */
  constructor(...args) {
    super(...args);

    /**
     * In case this object is virtual, primary item refers to the master object
     * that this object was forked from.
     *
     * Otherwise primary item is null
     *
     * @type {AbstractRecurringComponent}
     * @private
     */
    this._primaryItem = null;

    /**
     * Indicator whether this is a direct fork of a primary item, representing
     * the very same recurrence id
     *
     * @type {boolean}
     * @private
     */
    this._isExactForkOfPrimary = false;

    /**
     * The original recurrence-id of this occurrence.
     * Mostly needed for range exceptions with a range
     *
     * @type {DateTimeValue|null}
     * @private
     */
    this._originalRecurrenceId = null;

    /**
     * Instance of the recurrence manager.
     * This object is shared among all instances
     * of a recurrence-set
     *
     * @type {RecurrenceManager}
     * @private
     */
    this._recurrenceManager = null;

    /**
     * Indicator whether this component was modified
     * In case it was, the last-modified property
     * needs to be updated before saving the event
     *
     * @type {boolean}
     * @private
     */
    this._dirty = false;

    /**
     * Indicator whether there have been significant changes
     * In case the changes are considered significant,
     * the sequence needs to be incremented
     *
     * @type {boolean}
     * @private
     */
    this._significantChange = false;

    /**
     * Id of this AbstractRecurringComponent
     *
     * @type {string | null}
     * @private
     */
    this._cachedId = null;
  }

  /**
   * Gets the primary-item of this recurring item
   *
   * @return {AbstractRecurringComponent}
   */
  get primaryItem() {
    return this._primaryItem;
  }

  /**
   * Sets the primary-item of this recurring item
   *
   * @param {AbstractRecurringComponent} primaryItem The new primary-item
   */
  set primaryItem(primaryItem) {
    this._modify();
    this._primaryItem = primaryItem;
  }

  /**
   * Gets whether or not this is a fork of the primary item
   * for the same recurrence-id
   *
   * @return {boolean}
   */
  get isExactForkOfPrimary() {
    return this._isExactForkOfPrimary;
  }

  /**
   * Sets the isExactForkOfPrimary indicator, see getter for description
   *
   * @param {boolean} isExactForkOfPrimary Whether or not this is an exact fork
   */
  set isExactForkOfPrimary(isExactForkOfPrimary) {
    this._isExactForkOfPrimary = isExactForkOfPrimary;
  }

  /**
   * Gets the original recurrence-id
   *
   * @return {DateTimeValue}
   */
  get originalRecurrenceId() {
    return this._originalRecurrenceId;
  }

  /**
   * Sets the original recurrence-id
   *
   * @param {DateTimeValue} originalRecurrenceId The new original recurrence-id
   */
  set originalRecurrenceId(originalRecurrenceId) {
    this._originalRecurrenceId = originalRecurrenceId;
  }

  /**
   * Gets the recurrence-manager of this recurrence-set
   *
   * @return {RecurrenceManager}
   */
  get recurrenceManager() {
    return this._recurrenceManager;
  }

  /**
   * Sets the recurrence-manager of this recurrence-set
   *
   * @param {RecurrenceManager} recurrenceManager The new recurrence-manager
   */
  set recurrenceManager(recurrenceManager) {
    this._recurrenceManager = recurrenceManager;
  }

  /**
   * Gets the master-item of this recurring item
   *
   * @return {AbstractRecurringComponent}
   */
  get masterItem() {
    return this.recurrenceManager.masterItem;
  }

  /**
   * Returns whether this item is the master item
   *
   * @return {boolean}
   */
  isMasterItem() {
    return this.masterItem === this;
  }

  /**
   * Gets a unique ID for this occurrence of the event
   *
   * Please note that if the same event occurs in multiple calendars,
   * this id will not be unique. Software using this library will have to
   * manually mix in the calendar id into this id
   *
   * @return {string}
   */
  get id() {
    if (this._cachedId) {
      return this._cachedId;
    }
    if (this.startDate === null) {
      this._cachedId = encodeURIComponent(this.uid);
      return this._cachedId;
    }
    this._cachedId = [encodeURIComponent(this.uid), encodeURIComponent(this.getReferenceRecurrenceId().unixTime.toString())].join('###');
    return this._cachedId;
  }

  /**
   * Gets the UID property
   *
   * @return {string | null}
   */
  get uid() {
    return this.getFirstPropertyFirstValue('UID');
  }

  /**
   * Sets the UID property and the UID property of all related exceptions
   *
   * @param {string} uid The new UID
   */
  set uid(uid) {
    this._recurrenceManager.updateUID(uid);
  }

  /**
   * Gets the start date of the event
   *
   * @return {DateTimeValue}
   */
  get startDate() {
    return this.getFirstPropertyFirstValue('dtstart');
  }

  /**
   * Sets the start date of the event
   *
   * @param {DateTimeValue} start The new start-date to set
   */
  set startDate(start) {
    const oldStartDate = this.startDate;
    this.updatePropertyWithValue('dtstart', start);
    if (this.isMasterItem()) {
      this._recurrenceManager.updateStartDateOfMasterItem(start, oldStartDate);
    }
  }

  /**
   * Checks whether this item is part of a recurring set
   *
   * @return {boolean}
   */
  isPartOfRecurrenceSet() {
    return this.masterItem.isRecurring();
  }

  /**
   * Checks whether this component is recurring
   *
   * @return {boolean}
   */
  isRecurring() {
    return this.hasProperty('RRULE') || this.hasProperty('RDATE');
  }

  /**
   * Checks whether this component is a recurrence-exception
   *
   * @return {boolean}
   */
  isRecurrenceException() {
    return this.hasProperty('RECURRENCE-ID');
  }

  /**
   * Checks wether this component is a recurrence-exception
   * and whether it's modifying the future
   *
   * @return {boolean}
   */
  modifiesFuture() {
    if (!this.isRecurrenceException()) {
      return false;
    }
    const property = this.getFirstProperty('RECURRENCE-ID');
    return property.getParameterFirstValue('RANGE') === 'THISANDFUTURE';
  }

  /**
   * Creates an occurrence at the given time
   *
   * This is an internal function for calendar-js, used by the recurrence-manager
   * Do not call from outside
   *
   * @param {DateTimeValue} recurrenceId The recurrence-Id of the forked item
   * @param {DurationValue=} startDiff to be used when The start-diff (used for RECURRENCE-ID;RANGE=THISANDFUTURE)
   * @return {AbstractRecurringComponent}
   */
  forkItem(recurrenceId, startDiff = null) {
    const occurrence = this.clone();
    occurrence.recurrenceManager = this.recurrenceManager;
    occurrence.primaryItem = this;

    // Exact match for master item or recurrence-exception
    if (occurrence.getReferenceRecurrenceId().compare(recurrenceId) === 0) {
      occurrence.isExactForkOfPrimary = true;
    }
    if (!occurrence.hasProperty('DTSTART')) {
      throw new TypeError('Can\'t fork item without a DTSTART');
    }

    // Adjust RRULE COUNT if present
    const rrule = occurrence.getFirstPropertyFirstValue('RRULE');
    if (rrule?.count) {
      let index = occurrence.recurrenceManager.countAllOccurrencesBetween(occurrence.getReferenceRecurrenceId(), recurrenceId);
      index -= 1; // Don't count the forked occurrence
      rrule.count -= index;
      if (rrule.count < 1) {
        rrule.count = 1;
      }
    }
    if (occurrence.getFirstPropertyFirstValue('DTSTART').timezoneId !== recurrenceId.timezoneId) {
      const originalTimezone = occurrence.getFirstPropertyFirstValue('DTSTART').getICALTimezone();
      recurrenceId = recurrenceId.getInICALTimezone(originalTimezone);
    }
    occurrence.originalRecurrenceId = recurrenceId.clone();
    const dtStartValue = occurrence.getFirstPropertyFirstValue('DTSTART');
    let period = null;
    if (this._recurrenceManager.hasRecurrenceDate(false, recurrenceId)) {
      const recurrenceDate = this._recurrenceManager.getRecurrenceDate(false, recurrenceId);
      if (recurrenceDate instanceof PeriodValue) {
        period = recurrenceDate;
      }
    }
    let duration;
    if (occurrence.hasProperty('DTEND')) {
      const dtEndValue = occurrence.getFirstPropertyFirstValue('DTEND');
      duration = dtEndValue.subtractDateWithTimezone(dtStartValue);
    } else if (occurrence.hasProperty('DUE')) {
      const dueValue = occurrence.getFirstPropertyFirstValue('DUE');
      duration = dueValue.subtractDateWithTimezone(dtStartValue);
    }
    if (!(occurrence.isRecurrenceException() && occurrence.isExactForkOfPrimary)) {
      occurrence.updatePropertyWithValue('DTSTART', recurrenceId.clone());
      if (startDiff) {
        occurrence.startDate.addDuration(startDiff);
      }
      if (occurrence.hasProperty('DTEND')) {
        const dtEnd = occurrence.startDate.clone();
        dtEnd.addDuration(duration);
        occurrence.updatePropertyWithValue('DTEND', dtEnd);
      } else if (occurrence.hasProperty('DUE')) {
        const due = occurrence.startDate.clone();
        due.addDuration(duration);
        occurrence.updatePropertyWithValue('DUE', due);
      }
      if (period) {
        occurrence.deleteAllProperties('DTEND');
        occurrence.deleteAllProperties('DURATION');
        occurrence.updatePropertyWithValue('DTEND', period.end.clone());
      }
    }
    occurrence.resetDirty();
    return occurrence;
  }

  /**
   * Checks whether it's possible to create a recurrence exception for this event
   * It is possible
   *
   * @return {boolean}
   */
  canCreateRecurrenceExceptions() {
    let primaryIsRecurring = false;
    if (this.primaryItem && this.primaryItem.isRecurring()) {
      primaryIsRecurring = true;
    }
    return this.isRecurring() || this.modifiesFuture() || !this.isRecurring() && primaryIsRecurring;
  }

  /**
   * creates a recurrence exception based on this event
   * If the parameter thisAndAllFuture is set to true,
   * it will apply changes to this and all future occurrences
   *
   * @param {boolean} thisAndAllFuture Whether to create an exception for this and all future
   * @return {AbstractRecurringComponent[]} the AbstractRecurringComponent of the future events.
   * In case you set `thisAndAllFuture` to true, this will be an
   * AbstractRecurringComponent inside a entirely new calendar component
   */
  createRecurrenceException(thisAndAllFuture = false) {
    if (!this.canCreateRecurrenceExceptions()) {
      throw new Error('Can\'t create recurrence-exceptions for non-recurring items');
    }
    const previousPrimaryItem = this.primaryItem;

    /**
     * The overall support for RANGE=THISANDFUTURE is really bad.
     * Instead, we have to create a new event/journal/task and
     * set an until date on the old one.
     *
     * Also see:
     * - https://github.com/nextcloud/calendar/issues/7#issuecomment-292574813
     * - https://github.com/nextcloud/calendar/issues/7#issuecomment-299169143
     *
     * Right now, this replaces all future occurrence modifications,
     * including recurrence-exceptions, RDATES and EXDATES.
     * This is also how other CUAs handle it, but i would be happy
     * to put that up for discussion.
     *
     * Keeping future RDates + their recurrence-exceptions would be rather easy.
     * Updating recurrence-exceptions, that are based off normal recurrence rules,
     * could be very expensive.
     */
    if (thisAndAllFuture) {
      if (this.isExactForkOfPrimary) {
        // master item
        if (this.primaryItem.isMasterItem()) {
          this._overridePrimaryItem();
          return [this, this];
        }
      }
      this.removeThisOccurrence(true);
      this.recurrenceManager = new RecurrenceManager(this);
      this._originalRecurrenceId = null;
      this.primaryItem = this;
      this.updatePropertyWithValue('UID', v4());
      this._cachedId = null;
      this.addRelation('SIBLING', previousPrimaryItem.uid);
      previousPrimaryItem.addRelation('SIBLING', this.uid);

      // delete to make sure all parameters are gone
      this.deleteAllProperties('RECURRENCE-ID');
      this.deleteAllProperties('RDATE');
      this.deleteAllProperties('EXDATE');
      this.updatePropertyWithValue('CREATED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('SEQUENCE', 0);
      this._significantChange = false;
      this._dirty = false;
      this.root = this.root.constructor.fromEmpty();
      this.root.addComponent(this);
      this.parent = this.root;

      // this is a completely new event, we should set the RSVP of all attendees to true,
      // so that they receive an invitation to the new event, not only the cancellation of the old one
      for (const attendee of this.getAttendeeIterator()) {
        attendee.rsvp = true;
      }
    } else {
      // delete to make sure all parameters are gone
      this.deleteAllProperties('RECURRENCE-ID');
      this.recurrenceId = this.getReferenceRecurrenceId().clone();
      this.root.addComponent(this);
      this.recurrenceManager.relateRecurrenceException(this);
      this.primaryItem = this;
      this.deleteAllProperties('RDATE');
      this.deleteAllProperties('RRULE');
      this.deleteAllProperties('EXDATE');
      this.updatePropertyWithValue('CREATED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('SEQUENCE', 0);
      if (this.recurrenceManager.hasRecurrenceDate(false, this.getReferenceRecurrenceId())) {
        const recurDate = this.recurrenceManager.getRecurrenceDate(false, this.getReferenceRecurrenceId());
        if (recurDate instanceof PeriodValue) {
          const valueDateTimeRecurDate = recurDate.start;
          this.recurrenceManager.removeRecurrenceDate(false, recurDate);
          this.recurrenceManager.addRecurrenceDate(false, valueDateTimeRecurDate);
        }
      }
      this.originalRecurrenceId = null;
    }
    return [previousPrimaryItem, this];
  }

  /**
   * Deletes this occurrence from the series of recurring events
   * If the parameter thisAndAllFuture is set to true,
   * it will remove this and all future occurrences
   *
   * @param {boolean} thisAndAllFuture Whether to create an exception for this and all future
   * @throws EmptyRecurrenceSetError Thrown, when deleting an occurrence results in no more events
   * @return {boolean} true if this deleted the last occurrence in set, false if there are occurrences left
   */
  removeThisOccurrence(thisAndAllFuture = false) {
    if (!this.isPartOfRecurrenceSet()) {
      // When deleting an object, that's not part of a recurring set,
      // the calendar-document would be empty.
      return true;
    }
    if (thisAndAllFuture) {
      // To get the UNTIL date, just deduct one second.
      // That's also how macOS does it, so this should be fairly
      // well supported among all clients
      const recurrenceId = this.getReferenceRecurrenceId().clone();
      const until = recurrenceId.getInTimezone(Timezone.utc);
      until.addDuration(DurationValue.fromSeconds(-1));
      for (const recurValue of this.recurrenceManager.getRecurrenceRuleIterator()) {
        recurValue.until = until.clone();
      }
      for (const recurDate of this.recurrenceManager.getRecurrenceDateIterator()) {
        let valueToCheck = recurDate;
        if (recurDate instanceof PeriodValue) {
          valueToCheck = valueToCheck.start;
        }
        if (recurrenceId.compare(valueToCheck) <= 0) {
          this.recurrenceManager.removeRecurrenceDate(false, recurDate);
        }
      }
      for (const exceptionDate of this.recurrenceManager.getRecurrenceDateIterator(true)) {
        if (recurrenceId.compare(exceptionDate) <= 0) {
          this.recurrenceManager.removeRecurrenceDate(true, exceptionDate);
        }
      }
      for (const exception of this.recurrenceManager.getRecurrenceExceptionList()) {
        if (recurrenceId.compare(exception.recurrenceId) <= 0) {
          this.root.deleteComponent(exception);
          this.recurrenceManager.removeRecurrenceException(exception);
        }
      }
    } else {
      // Make sure we don't leave orphaned recurrence-exceptions
      if (this.isRecurrenceException() && !this.modifiesFuture()) {
        this.root.deleteComponent(this);
        this.recurrenceManager.removeRecurrenceException(this);
      }

      // If this is based on a recurrence-date, simply delete it
      // otherwise add an exception-date
      if (this.recurrenceManager.hasRecurrenceDate(false, this.getReferenceRecurrenceId())) {
        const recurDate = this.recurrenceManager.getRecurrenceDate(false, this.getReferenceRecurrenceId());
        this.recurrenceManager.removeRecurrenceDate(false, recurDate);
      } else {
        this.recurrenceManager.addRecurrenceDate(true, this.getReferenceRecurrenceId().clone());
      }
    }
    return this.recurrenceManager.isEmptyRecurrenceSet();
  }

  /**
   * @inheritDoc
   */
  clone() {
    const comp = super.clone();
    comp.resetDirty();
    return comp;
  }

  /**
   * Adds a new attendee
   *
   * @param {AttendeeProperty} attendee The attendee property to add
   * @private
   * @return {boolean}
   */
  _addAttendee(attendee) {
    // Check for different Attendee objects with the same uri
    for (const a of this.getAttendeeIterator()) {
      if (a.email === attendee.email) {
        return false;
      }
    }
    this.addProperty(attendee);
    return true;
  }

  /**
   * Adds a new attendee based on their name and email-address
   *
   * @param {string} name The name of the attendee to add
   * @param {string} email The email-address of the attendee to add
   * @return {boolean}
   */
  addAttendeeFromNameAndEMail(name, email) {
    const attendeeProperty = AttendeeProperty.fromNameAndEMail(name, email);
    return this._addAttendee(attendeeProperty);
  }

  /**
   * Adds a new attendee based on their properties
   *
   * @param {string} name The name of the attendee to add
   * @param {string} email The email-address of the attendee to add
   * @param {string} role The role of the attendee to add
   * @param {string} userType The type of attendee to add
   * @param {boolean} rsvp Whether or not to request a response from the attendee
   * @return {boolean}
   */
  addAttendeeFromNameEMailRoleUserTypeAndRSVP(name, email, role, userType, rsvp) {
    const attendeeProperty = AttendeeProperty.fromNameEMailRoleUserTypeAndRSVP(name, email, role, userType, rsvp, false);
    return this._addAttendee(attendeeProperty);
  }

  /**
   * Sets the organiser property from common-name and email address
   *
   * @param {string} name The name of the organizer
   * @param {string} email The email-address of the organizer
   */
  setOrganizerFromNameAndEMail(name, email) {
    this.deleteAllProperties('ORGANIZER');
    this.addProperty(AttendeeProperty.fromNameAndEMail(name, email, true));
  }

  /**
   * Adds a new attachment from raw data
   *
   * @param {string} data The data of the attachment
   * @param {string} formatType The mime-type of the attachment
   */
  addAttachmentFromData(data, formatType = null) {
    this.addProperty(AttachmentProperty.fromData(data, formatType));
  }

  /**
   * Adds a new attachment from a link
   *
   * @param {string} uri The URI of the attachment
   * @param {string} formatType The mime-type of the attachment
   */
  addAttachmentFromLink(uri, formatType = null) {
    this.addProperty(AttachmentProperty.fromLink(uri, formatType));
  }

  /**
   * Adds a new contact
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.2
   *
   * @param {string} contact The textual contact description to add
   */
  addContact(contact) {
    this.addProperty(new TextProperty('CONTACT', contact));
  }

  /**
   * Adds a new comment
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.4
   *
   * @param {string} comment The comment to add
   */
  addComment(comment) {
    this.addProperty(new TextProperty('COMMENT', comment));
  }

  /**
   * Adds a new image from raw data
   *
   * @param {string} data Data of the image to add
   * @param {string=} display What display-type the image is optimized for
   * @param {string=} formatType The mime-type of the image
   */
  addImageFromData(data, display = null, formatType = null) {
    this.addProperty(ImageProperty.fromData(data, display, formatType));
  }

  /**
   * Adds a new image from a link
   *
   * @param {string} uri The URI of the image to add
   * @param {string=} display What display-type the image is optimized for
   * @param {string=} formatType The mime-type of the image
   */
  addImageFromLink(uri, display = null, formatType = null) {
    this.addProperty(ImageProperty.fromLink(uri, display, formatType));
  }

  /**
   * Creates a new RELATED-TO property based on a relation-type and id
   * and adds it to this object
   *
   * @param {string} relType The type of relation to add
   * @param {string} relId The id of the related calendar-document
   */
  addRelation(relType, relId) {
    this.addProperty(RelationProperty.fromRelTypeAndId(relType, relId));
  }

  /**
   * Creates a new REQUEST-STATUS property based on code and message
   * and adds it to this object
   *
   * @param {number} code The status-code of the request status
   * @param {string} message The message of the request status
   */
  addRequestStatus(code, message) {
    this.addProperty(RequestStatusProperty.fromCodeAndMessage(code, message));
  }

  /**
   * Adds a new absolute alarm based on action and trigger time
   *
   * @param {string} action The type of alarm Action
   * @param {DateTimeValue} alarmTime The trigger time of the alarm
   * @return {AlarmComponent}
   */
  addAbsoluteAlarm(action, alarmTime) {
    const alarmComp = new AlarmComponent('VALARM', [['action', action], TriggerProperty.fromAbsolute(alarmTime)]);
    this.addComponent(alarmComp);
    return alarmComp;
  }

  /**
   * Adds a new relative alarm based on action, trigger time and relativeTo parameter
   *
   * @param {string} action The type of alarm Action
   * @param {DurationValue} alarmOffset The trigger time of the alarm
   * @param {boolean=} relatedToStart Whether or not the alarm is related to the event's start
   * @return {AlarmComponent}
   */
  addRelativeAlarm(action, alarmOffset, relatedToStart = true) {
    const alarmComp = new AlarmComponent('VALARM', [['action', action], TriggerProperty.fromRelativeAndRelated(alarmOffset, relatedToStart)]);
    this.addComponent(alarmComp);
    return alarmComp;
  }

  /**
   * Marks a certain property as edited
   *
   * @param {string} propertyName The name of the property
   */
  markPropertyAsDirty(propertyName) {
    this.markDirty();

    // Properties that must be considered a significant change
    // according to RFC 5546 Section 2.1.4
    const props = ['DTSTART', 'DTEND', 'DURATION', 'RRULE', 'RDATE', 'EXDATE', 'STATUS', ...getConfig('property-list-significant-change', [])];
    if (props.includes(uc(propertyName))) {
      this.markChangesAsSignificant();
    }
  }

  /**
   * Marks a certain component as edited
   *
   * @param {string} componentName The name of the component
   */
  markSubComponentAsDirty(componentName) {
    this.markDirty();
    if (getConfig('component-list-significant-change', []).includes(componentName)) {
      this.markChangesAsSignificant();
    }
  }

  /**
   * Returns whether or not this component is dirty
   *
   * @return {boolean}
   */
  isDirty() {
    return this._dirty || this._significantChange;
  }

  /**
   * Marks this object as dirty
   */
  markDirty() {
    this._dirty = true;
  }

  /**
   * Marks changes as significant. Can be called by the program using this lib
   */
  markChangesAsSignificant() {
    this._significantChange = true;
  }

  /**
   * Updates the event after modifications.
   *
   * @return {boolean} true if last-modified was updated
   */
  undirtify() {
    if (!this.isDirty()) {
      return false;
    }
    if (!this.hasProperty('SEQUENCE')) {
      this.sequence = 0;
    }
    this.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
    this.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
    if (this._significantChange) {
      this.sequence++;
    }
    this.resetDirty();
    return true;
  }

  /**
   * Resets the dirty indicators without updating DTSTAMP or LAST-MODIFIED
   */
  resetDirty() {
    this._dirty = false;
    this._significantChange = false;
  }

  /**
   * @inheritDoc
   */
  updatePropertyWithValue(propertyName, value) {
    super.updatePropertyWithValue(propertyName, value);
    if (uc(propertyName) === 'UID') {
      this._cachedId = null;
    }
    this.markPropertyAsDirty(propertyName);
  }

  /**
   * @inheritDoc
   */
  addProperty(property) {
    this.markPropertyAsDirty(property.name);
    property.subscribe(() => this.markPropertyAsDirty(property.name));
    return super.addProperty(property);
  }

  /**
   * @inheritDoc
   */
  deleteProperty(property) {
    this.markPropertyAsDirty(property.name);
    return super.deleteProperty(property);
  }

  /**
   * @inheritDoc
   */
  deleteAllProperties(propertyName) {
    this.markPropertyAsDirty(propertyName);
    return super.deleteAllProperties(propertyName);
  }

  /**
   * @inheritDoc
   */
  addComponent(component) {
    this.markSubComponentAsDirty(component.name);
    component.subscribe(() => this.markSubComponentAsDirty(component.name));
    return super.addComponent(component);
  }

  /**
   * @inheritDoc
   */
  deleteComponent(component) {
    this.markSubComponentAsDirty(component.name);
    return super.deleteComponent(component);
  }

  /**
   * @inheritDoc
   */
  deleteAllComponents(componentName) {
    this.markSubComponentAsDirty(componentName);
    return super.deleteAllComponents(componentName);
  }

  /**
   * Gets a recurrence-id that has to be used to refer to this event.
   * This is used for recurrence-management
   *
   * @return {DateTimeValue|null}
   */
  getReferenceRecurrenceId() {
    if (this.originalRecurrenceId) {
      return this.originalRecurrenceId;
    } else if (this.recurrenceId) {
      return this.recurrenceId;
    } else if (this.startDate) {
      return this.startDate;
    }
    return null;
  }

  /**
   * Overrides the master item with this one
   *
   * @private
   */
  _overridePrimaryItem() {
    const oldStartDate = this.primaryItem.startDate;
    for (const property of this.primaryItem.getPropertyIterator()) {
      this.primaryItem.deleteProperty(property);
    }
    for (const property of this.getPropertyIterator()) {
      this.primaryItem.addProperty(property);
    }
    this.recurrenceManager.resetCache();
    if (this.startDate.compare(oldStartDate) !== 0) {
      this.recurrenceManager.updateStartDateOfMasterItem(this.startDate, oldStartDate);
    }
  }

  /**
   * @inheritDoc
   */
  static _getConstructorForComponentName(componentName) {
    return getConstructorForComponentName$1(componentName);
  }

  /**
   * @inheritDoc
   */
  static fromICALJs(...args) {
    const comp = super.fromICALJs(...args);
    comp.resetDirty();
    return comp;
  }
}

/**
 * Date-Time stamp of this object.
 * It has different meaning, based on whether or not a method is defined
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.2
 *
 * @name EventComponent#stampTime
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'stampTime',
  iCalendarName: 'DTSTAMP'
});

/**
 * Recurrence-ID of this object, used for recurrence-exceptions
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.4
 *
 * @name EventComponent#recurrenceId
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'recurrenceId',
  iCalendarName: 'RECURRENCE-ID'
});

/**
 * Special color for this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.9
 *
 * @name EventComponent#color
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'color');

/**
 * Creation Time of this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.1
 *
 * @name EventComponent#creationTime
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'creationTime',
  iCalendarName: 'CREATED'
});

/**
 * The time this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.3
 *
 * @name EventComponent#modificationTime
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'modificationTime',
  iCalendarName: 'LAST-MODIFIED'
});

/**
 * Organizer of this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.3
 *
 * @name EventComponent#organizer
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'organizer');

/**
 * Revision of this this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.4
 *
 * @name EventComponent#sequence
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'sequence');

/**
 * Status of this event / journal / task
 * This indicates whether an event is tentative / confirmed / cancelled
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.11
 *
 * @name EventComponent#status
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'status');

/**
 * URL of a more dynamic rendition of this event / journal / task
 * DO NOT use this to simply point to a website merely related.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.6
 *
 * @name EventComponent#url
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'url');

/**
 * Title of this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.12
 *
 * @name EventComponent#title
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'title',
  iCalendarName: 'SUMMARY'
});

/**
 * Access class of this event / journal / task
 * This determines what other users can see when sharing
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.3
 *
 * @name EventComponent#accessClass
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'accessClass',
  iCalendarName: 'class',
  allowedValues: ['PUBLIC', 'PRIVATE', 'CONFIDENTIAL'],
  defaultValue: 'PUBLIC',
  unknownValue: 'PRIVATE'
});

/**
 * Returns an iterator over all categories
 * If the parameter lang is given, it will only
 * return an iterator for Categories matching that language
 *
 * @name AbstractRecurringComponent#getCategoryIterator
 * @function
 * @param {string=} lang
 * @return {IterableIterator<string>}
 */

/**
 * Returns a list of all categories
 * If the parameter lang is given, it will only
 * return an iterator for Categories matching that language
 *
 * @name AbstractRecurringComponent#getCategoryList
 * @function
 * @param {string=} lang
 * @return {string[]}
 */

/**
 * Adds a new category
 *
 * @name AbstractRecurringComponent#addCategory
 * @function
 * @param {string} category
 * @param {string=} lang
 */

/**
 * Removes a category
 *
 * @name AbstractRecurringComponent#removeCategory
 * @function
 * @param {string} category
 * @param {string=} lang
 */

/**
 * Clear all categories of a given language
 *
 * @name AbstractRecurringComponent#clearAllCategories
 * @function
 */
advertiseMultiValueStringPropertySeparatedByLang(AbstractRecurringComponent.prototype, {
  name: 'category',
  pluralName: 'categories',
  iCalendarName: 'CATEGORIES'
});

/**
 * Returns an iterator over all attendees
 *
 * @name AbstractRecurringComponent#getAttendeeIterator
 * @function
 * @return {IterableIterator<AttendeeProperty>}
 */

/**
 * Gets a list of all attendees
 *
 * @name AbstractRecurringComponent#getAttendeeList
 * @function
 * @return {AttachmentProperty[]}
 */

/**
 * Removes an attendee from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeAttendee
 * @function
 * @param {AttendeeProperty} attendee
 */

/**
 * Removes all attendees from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllAttendees
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'attendee'
});

/**
 * Returns an iterator over all attachments
 *
 * @name AbstractRecurringComponent#getAttachmentIterator
 * @function
 * @return {IterableIterator<AttachmentProperty>}
 */

/**
 * Gets a list of all attachments
 *
 * @name AbstractRecurringComponent#getAttachmentList
 * @function
 * @return {AttachmentProperty[]}
 */

/**
 * Removes one attachment from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeAttachment
 * @function
 * @param {AttachmentProperty} attachment
 */

/**
 * Removes all attachments from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllAttachments
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'attachment',
  iCalendarName: 'ATTACH'
});

/**
 * Returns an iterator over all relation properties
 *
 * @name AbstractRecurringComponent#getRelationIterator
 * @function
 * @return {IterableIterator<RelationProperty>}
 */

/**
 * Returns a list of all relation properties
 *
 * @name AbstractRecurringComponent#getRelationList
 * @function
 * @return {RelationProperty[]}
 */

/**
 * Removes a relation from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeRelation
 * @function
 * @param {RelationProperty} relation
 */

/**
 * Removes all relations from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllRelations
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'relation',
  iCalendarName: 'RELATED-TO'
});

/**
 * Returns an iterator over all comments in this event / journal / task
 *
 * @name AbstractRecurringComponent#getCommentIterator
 * @function
 * @return {IterableIterator<TextProperty>}
 */

/**
 * Returns a list of all comments in this event / journal / task
 *
 * @name AbstractRecurringComponent#getCommentList
 * @function
 * @return {TextProperty[]}
 */

/**
 * Removes a comment from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeComment
 * @function
 * @param {TextProperty} comment
 */

/**
 * Removes all comments from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllComments
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, 'comment');

/**
 * Returns an iterator over all contacts referenced in this event / journal / task
 *
 * @name AbstractRecurringComponent#getContactIterator
 * @function
 * @return {IterableIterator<TextProperty>}
 */

/**
 * Returns a list of all contacts referenced in this event / journal / task
 *
 * @name AbstractRecurringComponent#getContactList
 * @function
 * @return {TextProperty[]}
 */

/**
 * Removes one contact from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeContact
 * @function
 * @param {TextProperty} contact
 */

/**
 * Removes all contacts from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllContacts
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, 'contact');

/**
 * Returns an iterator over all image properties
 *
 * @name AbstractRecurringComponent#getImageIterator
 * @function
 * @return {IterableIterator<ImageProperty>}
 */

/**
 * Returns a list of all image properties
 *
 * @name AbstractRecurringComponent#getImageList
 * @function
 * @return {ImageProperty[]}
 */

/**
 * Removes one image from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeImage
 * @function
 * @param {ImageProperty} image
 */

/**
 * Removes all images from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllImages
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, 'image');

/**
 * Returns an iterator over all request status
 *
 * @name AbstractRecurringComponent#getRequestStatusIterator
 * @function
 * @return {IterableIterator<RequestStatusProperty>}
 */

/**
 * Returns a list of all request status
 *
 * @name AbstractRecurringComponent#getRequestStatusList
 * @function
 * @return {RequestStatusProperty[]}
 */

/**
 * Removes one request status from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeRequestStatus
 * @function
 * @param {RequestStatusProperty} requestStatus
 */

/**
 * Removes all request status from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllRequestStatus
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'requestStatus',
  pluralName: 'requestStatus',
  iCalendarName: 'REQUEST-STATUS'
});

/**
 * Returns an iterator of all alarms
 *
 * @name AbstractRecurringComponent#getAlarmIterator
 * @function
 * @return {IterableIterator<AlarmComponent>}
 */

/**
 * Returns a list of all alarms
 *
 * @name AbstractRecurringComponent#getAlarmList
 * @function
 * @return {AlarmComponent[]}
 */

/**
 * Removes an alarm from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeAlarm
 * @function
 * @param {AlarmComponent} alarm
 */

/**
 * Removes all alarms from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllAlarms
 * @function
 */
advertiseComponent(AbstractRecurringComponent.prototype, 'alarm');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets kind of birthday event
 * returns "BDAY", "DEATHDATE", "ANNIVERSARY"
 * or null if this is not a birthday event
 *
 * @param {EventComponent} eventComponent The eventComponent of the birthday event
 * @return {null|string}
 */
function getTypeOfBirthdayEvent(eventComponent) {
  return eventComponent.getFirstPropertyFirstValue('X-NEXTCLOUD-BC-FIELD-TYPE');
}

/**
 * Gets icon for the birthday type
 *
 * @param {EventComponent} eventComponent The eventComponent of the birthday event
 * @return {string|null}
 */
function getIconForBirthday(eventComponent) {
  const birthdayType = getTypeOfBirthdayEvent(eventComponent);
  switch (birthdayType) {
    case 'BDAY':
      return '🎂';
    case 'DEATHDATE':
      return '⚰️';
    case 'ANNIVERSARY':
      return '💍';
    default:
      return null;
  }
}

/**
 * Returns the age of the birthday person or null of no birth-year given
 *
 * @param {EventComponent} eventComponent The eventComponent of the birthday event
 * @param {number} yearOfOccurrence The year to calculate the age for
 * @return {null|number}
 */
function getAgeOfBirthday(eventComponent, yearOfOccurrence) {
  if (!eventComponent.hasProperty('X-NEXTCLOUD-BC-YEAR')) {
    return null;
  }
  const yearOfBirth = eventComponent.getFirstPropertyFirstValue('X-NEXTCLOUD-BC-YEAR');
  return parseInt(yearOfOccurrence, 10) - parseInt(yearOfBirth, 10);
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class EventComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.1
 */
class EventComponent extends AbstractRecurringComponent {
  /**
   * Returns whether this event is an all-day event
   *
   * @return {boolean}
   */
  isAllDay() {
    return this.startDate.isDate && this.endDate.isDate;
  }

  /**
   * Checks whether it's possible to switch from date-time to date or vise-versa
   *
   * @return {boolean}
   */
  canModifyAllDay() {
    return !this.recurrenceManager.masterItem.isRecurring();
  }

  /**
   * Gets the calculated end-date of the event
   *
   * Quote from RFC 5545 3.6.1:
   * The "DTSTART" property for a "VEVENT" specifies the inclusive
   * start of the event.  For recurring events, it also specifies the
   * very first instance in the recurrence set.  The "DTEND" property
   * for a "VEVENT" calendar component specifies the non-inclusive end
   * of the event.  For cases where a "VEVENT" calendar component
   * specifies a "DTSTART" property with a DATE value type but no
   * "DTEND" nor "DURATION" property, the event's duration is taken to
   * be one day.  For cases where a "VEVENT" calendar component
   * specifies a "DTSTART" property with a DATE-TIME value type but no
   * "DTEND" property, the event ends on the same calendar date and
   * time of day specified by the "DTSTART" property.
   *
   * @return {DateTimeValue}
   */
  get endDate() {
    if (this.hasProperty('dtend')) {
      return this.getFirstPropertyFirstValue('dtend');
    }
    const dtend = this.startDate.clone();
    if (this.hasProperty('duration')) {
      dtend.addDuration(this.getFirstPropertyFirstValue('duration'));
    } else if (this.startDate.isDate) {
      dtend.addDuration(DurationValue.fromSeconds(60 * 60 * 24));
    } // There is nothing to do when this event is not allday

    return dtend;
  }

  /**
   * Sets the end time of the event
   *
   * @param {DateTimeValue} end The end of the event
   */
  set endDate(end) {
    this.deleteAllProperties('duration');
    this.updatePropertyWithValue('dtend', end);
  }

  /**
   * Gets the calculated duration of the event
   *
   * @return {DurationValue}
   */
  get duration() {
    if (this.hasProperty('duration')) {
      return this.getFirstPropertyFirstValue('duration');
    }
    return this.startDate.subtractDateWithTimezone(this.endDate);
  }

  /**
   * Sets the calculated duration of the event
   *
   * @param {DurationValue} duration The duration of the event
   */
  set duration(duration) {
    this.deleteAllProperties('dtend');
    this.updatePropertyWithValue('duration', duration);
  }

  /**
   * Sets the geographical position based on latitude and longitude
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
   *
   * @param {number} lat - latitude
   * @param {number} long - longitude
   */
  setGeographicalPositionFromLatitudeAndLongitude(lat, long) {
    this.deleteAllProperties('GEO');
    this.addProperty(GeoProperty.fromPosition(lat, long));
  }

  /**
   * Adds a new conference property based on URI, label and features
   *
   * @url https://tools.ietf.org/html/rfc7986#section-5.11
   *
   * @param {string} uri The URI of the conference system
   * @param {string=} label The label for the conference system
   * @param {string[]=} features The features of the conference system
   */
  addConference(uri, label = null, features = null) {
    this._modify();
    this.addProperty(ConferenceProperty.fromURILabelAndFeatures(uri, label, features));
  }

  /**
   * Adds a duration to the start of the event
   *
   * @param {DurationValue} duration The duration to add
   */
  addDurationToStart(duration) {
    this.startDate.addDuration(duration);
  }

  /**
   * Adds a duration to the end of the event
   *
   * @param {DurationValue} duration The duration to add
   */
  addDurationToEnd(duration) {
    const endDate = this.endDate;
    endDate.addDuration(duration);
    this.endDate = endDate;
  }

  /**
   * Shifts the entire event by the given duration
   *
   * @param {DurationValue} delta The duration to shift event by
   * @param {boolean} allDay Whether the updated event should be all-day or not
   * @param {Timezone} defaultTimezone The default timezone if moving from all-day to timed event
   * @param {DurationValue} defaultAllDayDuration The default all-day duration if moving from timed to all-day
   * @param {DurationValue} defaultTimedDuration The default timed duration if moving from all-day to timed
   */
  shiftByDuration(delta, allDay, defaultTimezone, defaultAllDayDuration, defaultTimedDuration) {
    const currentAllDay = this.isAllDay();
    if (currentAllDay !== allDay && !this.canModifyAllDay()) {
      throw new TypeError('Can\'t modify all-day of this event');
    }
    this.startDate.isDate = allDay;
    this.startDate.addDuration(delta);

    // If this event was moved from the all-day area into the time-grid,
    // then we have to add a timezone and the default duration
    if (currentAllDay && !allDay) {
      this.startDate.replaceTimezone(defaultTimezone);
      this.endDate = this.startDate.clone();
      this.endDate.addDuration(defaultTimedDuration);
    }

    // If this event was moved from the time-grid into the all-day area,
    // then we have to change the default duration
    if (!currentAllDay && allDay) {
      this.endDate = this.startDate.clone();
      this.endDate.addDuration(defaultAllDayDuration);
    }

    // If this event was only moved inside the time-grid or only inside
    // the all-day area, then we only have to adjust the end-date
    if (currentAllDay === allDay) {
      const endDate = this.endDate;
      endDate.addDuration(delta);
      this.endDate = endDate;
    }
  }

  /**
   * Checks if this is a birthday event
   *
   * @return {boolean}
   */
  isBirthdayEvent() {
    return getTypeOfBirthdayEvent(this) === 'BDAY';
  }

  /**
   * Gets the icon to the birthday event
   *
   * @return {string}
   */
  getIconForBirthdayEvent() {
    return getIconForBirthday(this);
  }

  /**
   * Calculates the age of the birthday
   *
   * @return {number}
   */
  getAgeForBirthdayEvent() {
    return getAgeOfBirthday(this, this.startDate.year);
  }

  /**
   * Serializes the entire series to ICS
   *
   * @return {string}
   */
  toICSEntireSeries() {
    return this.root.toICS();
  }

  /**
   * Serializes exactly this recurrence to ICS
   * It removes all recurrence information
   *
   * @return {string}
   */
  toICSThisOccurrence() {
    const clone = this.clone();
    clone.deleteAllProperties('RRULE');
    clone.deleteAllProperties('EXRULE');
    clone.deleteAllProperties('RDATE');
    clone.deleteAllProperties('EXDATE');
    clone.deleteAllProperties('RECURRENCE-ID');
    clone.root = clone.root.constructor.fromEmpty();
    clone.parent = clone.root;
    clone.root.addComponent(clone);
    return clone.root.toICS();
  }

  /**
   * Checks if this event is in a given time-frame
   *
   * @param {DateTimeValue} start Start of time-range to check
   * @param {DateTimeValue} end End of time-range to check
   * @return {boolean}
   */
  isInTimeFrame(start, end) {
    return start.compare(this.endDate) <= 0 && end.compare(this.startDate) >= 0;
  }
}

/**
 * Time-transparency of this event.
 * If set to TRANSPARENT, this event will be ignored for FREE/BUSY calculations.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.7
 *
 * @name EventComponent#timeTransparency
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, {
  name: 'timeTransparency',
  iCalendarName: 'TRANSP',
  allowedValues: ['OPAQUE', 'TRANSPARENT'],
  defaultValue: 'OPAQUE'
});

/**
 * Description of this event.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name EventComponent#description
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, 'description');

/**
 * Geographical position of this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
 *
 * @name EventComponent#geographicalPosition
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, {
  name: 'geographicalPosition',
  iCalendarName: 'GEO'
});

/**
 * Location that this event takes place in
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.7
 *
 * @name EventComponent#location
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, 'location');

/**
 * Priority of this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.9
 *
 * @name EventComponent#priority
 * @type Number
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, {
  name: 'priority',
  allowedValues: Array(9).keys(),
  defaultValue: 0,
  unknownValue: 0
});

/**
 * Returns an iterator over all resources
 * If the parameter lang is given, it will only
 * return an iterator for Resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#getResourceIterator
 * @function
 * @param {string=} lang
 * @return {IterableIterator<string>}
 */

/**
 * Returns a list of all resources
 * If the parameter lang is given, it will only
 * return an iterator for resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#getResourceList
 * @function
 * @param {string=} lang
 * @return {string[]}
 */

/**
 * Adds a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#addResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#removeResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes all resources from this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#clearAllResources
 * @function
 * @param {string=} lang
 */
advertiseMultiValueStringPropertySeparatedByLang(EventComponent.prototype, {
  name: 'resource',
  iCalendarName: 'RESOURCES'
});

/**
 * Gets an iterator over all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#getConferenceIterator
 * @function
 * @return {IterableIterator<ConferenceProperty>}
 */

/**
 * Gets a list of all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#getConferenceList
 * @function
 * @return {ConferenceProperty[]}
 */

/**
 * Removes a conference from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#removeConference
 * @function
 * @param {ConferenceProperty} conference
 */

/**
 * Removes all conferences from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#clearAllConferences
 * @function
 */
advertiseMultipleOccurrenceProperty(EventComponent.prototype, 'conference');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class FreeBusyComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.4
 */
class FreeBusyComponent extends AbstractComponent {
  /**
   * Gets the start-date of the FreeBusy component
   *
   * @return {DateTimeValue}
   */
  get startDate() {
    return this.getFirstPropertyFirstValue('DTSTART');
  }

  /**
   * Sets the start-date of the FreeBusy component
   *
   * @param {DateTimeValue} startDate The start of the queried time-range
   */
  set startDate(startDate) {
    this._modify();
    this.updatePropertyWithValue('DTSTART', startDate.getInTimezone(Timezone.utc));
  }

  /**
   * Gets the end-date of the FreeBusy component
   *
   * @return {DateTimeValue}
   */
  get endDate() {
    return this.getFirstPropertyFirstValue('DTEND');
  }

  /**
   * Sets the start-date of the FreeBusy component
   *
   * @param {DateTimeValue} endDate The end of the queried time-range
   */
  set endDate(endDate) {
    this._modify();
    this.updatePropertyWithValue('DTEND', endDate.getInTimezone(Timezone.utc));
  }

  /**
   * Gets an iterator over all FreeBusyProperties
   */
  *getFreeBusyIterator() {
    yield* this.getPropertyIterator('FREEBUSY');
  }

  /**
   * Adds a new attendee based on their name and email-address
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
   *
   * @param {string} name The name of the attendee to add
   * @param {string} email The email-address of the attendee to add
   */
  addAttendeeFromNameAndEMail(name, email) {
    this._modify();
    this.addProperty(AttendeeProperty.fromNameAndEMail(name, email));
  }

  /**
   * Sets the organiser property from common-name and email address
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.3
   *
   * @param {string} name The name of the organizer
   * @param {string} email The email-address of the organizer
   */
  setOrganizerFromNameAndEMail(name, email) {
    this._modify();
    this.deleteAllProperties('ORGANIZER');
    this.addProperty(AttendeeProperty.fromNameAndEMail(name, email, true));
  }
}

/**
 * The organizer of this FreeBusy component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.3
 *
 * @name FreeBusyComponent#organizer
 * @type {AttendeeProperty}
 */
advertiseSingleOccurrenceProperty(FreeBusyComponent.prototype, 'organizer');

/**
 * The UID of this FreeBusy component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.7
 *
 * @name FreeBusyComponent#organizer
 * @type {AttendeeProperty}
 */
advertiseSingleOccurrenceProperty(FreeBusyComponent.prototype, 'uid');

/**
 * Returns an iterator of all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#getAttendeeIterator
 * @function
 * @return {IterableIterator<AttendeeProperty>}
 */

/**
 * Returns a list of all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#getAttendeeList
 * @function
 * @return {AttendeeProperty[]}
 */

/**
 * Removes an attendee
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#removeAttendee
 * @function
 * @param {AttendeeProperty} attendee
 */

/**
 * Removes all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#clearAllAttendees
 * @function
 */
advertiseMultipleOccurrenceProperty(FreeBusyComponent.prototype, 'attendee');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class JournalComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.3
 */
class JournalComponent extends AbstractRecurringComponent {
  /**
   * Adds a new description property
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
   *
   * @param {string} description The description text
   */
  addDescription(description) {
    this.addProperty(new TextProperty('DESCRIPTION', description));
  }
}

/**
 * Gets an iterator over all description properties
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#getDescriptionIterator
 * @function
 * @return {IterableIterator<ConferenceProperty>}
 */

/**
 * Gets a list of all description properties
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#getDescriptionList
 * @function
 * @return {ConferenceProperty[]}
 */

/**
 * Removes a description from this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#removeDescription
 * @function
 * @param {ConferenceProperty} conference
 */

/**
 * Removes all descriptions from this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#clearAllDescriptions
 * @function
 */
advertiseMultipleOccurrenceProperty(JournalComponent.prototype, 'description');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TimezoneComponent
 * @classdesc
 *
 * There are no advertised properties / components for the TimezoneComponent,
 * since we don't care about it.
 * Editing / accessing the timezone information directly is not a use-case
 * All the timezone-handling is done by the underlying ICAL.JS
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.5
 */
class TimezoneComponent extends AbstractComponent {
  /**
   * Returns a calendar-js Timezone object
   *
   * @return {Timezone}
   */
  toTimezone() {
    return new Timezone(this.toICALJs());
  }
}

/**
 * The timezoneId of this timezone-component
 *
 * @name TimezoneComponent#timezoneId
 * @type {string}
 */
advertiseSingleOccurrenceProperty(TimezoneComponent.prototype, {
  name: 'timezoneId',
  iCalendarName: 'tzid'
});

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ToDoComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.2
 */
class ToDoComponent extends AbstractRecurringComponent {
  /**
   * Returns whether this event is an all-day event
   *
   * @return {boolean}
   */
  isAllDay() {
    const propertiesToCheck = ['DTSTART', 'DUE'];
    for (const propertyToCheck of propertiesToCheck) {
      if (this.hasProperty(propertyToCheck)) {
        return this.getFirstPropertyFirstValue(propertyToCheck).isDate;
      }
    }

    // If a task is not associated with any date, it is defined to
    // occur on any successive date until it is completed.
    // We are treating it as all-day in that case.
    return true;
  }

  /**
   * Checks whether it's possible to switch from date-time to date or vise-versa
   *
   * @return {boolean}
   */
  canModifyAllDay() {
    if (!this.hasProperty('dtstart') && !this.hasProperty('due')) {
      return false;
    }
    return !this.recurrenceManager.masterItem.isRecurring();
  }

  /**
   * Gets the calculated end-date of the task
   *
   * If there is a due-date, we will just return that.
   * If there is a start-date and a duration, we will
   * calculate the end-date based on that.
   *
   * If there is neither a due-date nor a combination
   * of start-date and duration, we just return null
   *
   * @return {DateTimeValue|null}
   */
  get endDate() {
    if (this.hasProperty('due')) {
      return this.getFirstPropertyFirstValue('due');
    }
    if (!this.hasProperty('dtstart') || !this.hasProperty('duration')) {
      return null;
    }
    const endDate = this.startDate.clone();
    endDate.addDuration(this.getFirstPropertyFirstValue('duration'));
    return endDate;
  }

  /**
   * Shifts the entire task by the given duration
   *
   * @param {DurationValue} delta The duration to shift event by
   * @param {boolean} allDay Whether the updated event should be all-day or not
   * @param {Timezone} defaultTimezone The default timezone if moving from all-day to timed event
   * @param {DurationValue} defaultAllDayDuration The default all-day duration if moving from timed to all-day
   * @param {DurationValue} defaultTimedDuration The default timed duration if moving from all-day to timed
   */
  shiftByDuration(delta, allDay, defaultTimezone, defaultAllDayDuration, defaultTimedDuration) {
    const currentAllDay = this.isAllDay();
    if (!this.hasProperty('dtstart') && !this.hasProperty('due')) {
      throw new TypeError('This task does not have a start-date nor due-date');
    }
    if (currentAllDay !== allDay && !this.canModifyAllDay()) {
      throw new TypeError('Can\'t modify all-day of this todo');
    }

    // If this task has a start-date, update it
    // This is especially important, if you shift
    // the task by a negative duration, because
    // dtstart always has to be prior to the due date
    if (this.hasProperty('dtstart')) {
      this.startDate.isDate = allDay;
      this.startDate.addDuration(delta);
      if (currentAllDay && !allDay) {
        this.startDate.replaceTimezone(defaultTimezone);
      }
    }
    if (this.hasProperty('due')) {
      this.dueTime.isDate = allDay;
      this.dueTime.addDuration(delta);
      if (currentAllDay && !allDay) {
        this.dueTime.replaceTimezone(defaultTimezone);
      }
    }
  }

  /**
   * Checks if this event is in a given time-frame
   *
   * @param {DateTimeValue} start Start of time-range to check
   * @param {DateTimeValue} end End of time-range to check
   * @return {boolean}
   */
  isInTimeFrame(start, end) {
    if (!this.hasProperty('dtstart') && !this.hasProperty('due')) {
      return true;
    }
    if (!this.hasProperty('dtstart') && this.hasProperty('due')) {
      return start.compare(this.endDate) <= 0;
    }
    return start.compare(this.endDate) <= 0 && end.compare(this.startDate) >= 0;
  }

  /**
   * Gets the geographical position property
   *
   * @return {GeoProperty}
   */
  get geographicalPosition() {
    return this.getFirstProperty('GEO');
  }

  /**
   * Sets the geographical position based on latitude and longitude
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
   *
   * @param {number} lat - latitude
   * @param {number} long - longitude
   */
  setGeographicalPositionFromLatitudeAndLongitude(lat, long) {
    this.deleteAllProperties('GEO');
    this.addProperty(GeoProperty.fromPosition(lat, long));
  }

  /**
   * Adds a new conference property based on URI, label and features
   *
   * @url https://tools.ietf.org/html/rfc7986#section-5.11
   *
   * @param {string} uri The URI of the conference
   * @param {string=} label The label of the conference
   * @param {string[]=} features Supported features of conference-system
   */
  addConference(uri, label = null, features = null) {
    this.addProperty(ConferenceProperty.fromURILabelAndFeatures(uri, label, features));
  }

  /**
   * Gets a recurrence-id that has to be used to refer to this task.
   * This is used for recurrence-management.
   *
   * Gracefully handles the case where a task has no start-date, but a due-date.
   *
   * @return {DateTimeValue|null}
   */
  getReferenceRecurrenceId() {
    return super.getReferenceRecurrenceId() ?? this.endDate;
  }
}

/**
 * The time when a task was completed
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.1
 *
 * @name ToDoComponent#completedTime
 * @type {DateTimeValue}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'completedTime',
  iCalendarName: 'COMPLETED'
});

/**
 * The time when a task is due
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.3
 *
 * @name ToDoComponent#dueTime
 * @type {DateTimeValue}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'dueTime',
  iCalendarName: 'DUE'
});

/**
 * The time when a task was completed
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.5
 *
 * @name ToDoComponent#duration
 * @type {DurationValue}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'duration'
});

/**
 * The percentage a task was already fulfilled
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.8
 *
 * @name ToDoComponent#percent
 * @type {number}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'percent',
  iCalendarName: 'PERCENT-COMPLETE'
});

/**
 * Description of this task.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name ToDoComponent#description
 * @type {string}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, 'description');

/**
 * Location of this task.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.7
 *
 * @name ToDoComponent#location
 * @type {string}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, 'location');

/**
 * Priority of this task.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.9
 *
 * @name ToDoComponent#priority
 * @type {string}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'priority',
  allowedValues: Array.from(Array(10).keys()),
  defaultValue: 0,
  unknownValue: 0
});

/**
 * Returns an iterator over all resources
 * If the parameter lang is given, it will only
 * return an iterator for Resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#getResourceIterator
 * @function
 * @param {string=} lang
 * @return {IterableIterator<string>}
 */

/**
 * Returns a list of all resources
 * If the parameter lang is given, it will only
 * return an iterator for resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#getResourceList
 * @function
 * @param {string=} lang
 * @return {string[]}
 */

/**
 * Adds a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#addResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#removeResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes all resources from this task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#clearAllResources
 * @function
 * @param {string=} lang
 */
advertiseMultiValueStringPropertySeparatedByLang(ToDoComponent.prototype, {
  name: 'resource',
  iCalendarName: 'RESOURCES'
});

/**
 * Gets an iterator over all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#getConferenceIterator
 * @function
 * @return {IterableIterator<ConferenceProperty>}
 */

/**
 * Gets a list of all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#getConferenceList
 * @function
 * @return {ConferenceProperty[]}
 */

/**
 * Removes a conference from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#removeConference
 * @function
 * @param {ConferenceProperty} conference
 */

/**
 * Removes all conferences from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#clearAllConferences
 * @function
 */
advertiseMultipleOccurrenceProperty(ToDoComponent.prototype, 'conference');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets the constructor for a component name
 * This will only return a constructor for components,
 * that can be used in the root of a calendar-document
 *
 * @param {string} compName Name of the component to get constructor for
 * @return {AbstractComponent|ToDoComponent|JournalComponent|FreeBusyComponent|TimezoneComponent|EventComponent}
 */
function getConstructorForComponentName(compName) {
  switch (uc(compName)) {
    case 'VEVENT':
      return EventComponent;
    case 'VFREEBUSY':
      return FreeBusyComponent;
    case 'VJOURNAL':
      return JournalComponent;
    case 'VTIMEZONE':
      return TimezoneComponent;
    case 'VTODO':
      return ToDoComponent;
    default:
      return AbstractComponent;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * This class represents one VCALENDAR block
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.4
 */
class CalendarComponent extends AbstractComponent {
  /**
   * Constructor
   *
   * @inheritDoc
   */
  constructor(name = 'VCALENDAR', properties = [], components = []) {
    super(name, properties, components);
    this.root = this;
    this.parent = null;
  }

  /**
   * Gets an iterator over all VTIMEZONE components
   */
  *getTimezoneIterator() {
    yield* this.getComponentIterator('vtimezone');
  }

  /**
   * Gets an iterator over all VObject components
   */
  *getVObjectIterator() {
    yield* this.getEventIterator();
    yield* this.getJournalIterator();
    yield* this.getTodoIterator();
  }

  /**
   * Gets an iterator over all VEVENT components
   */
  *getEventIterator() {
    yield* this.getComponentIterator('vevent');
  }

  /**
   * Gets an iterator over all VFREEBUSY components
   */
  *getFreebusyIterator() {
    yield* this.getComponentIterator('vfreebusy');
  }

  /**
   * Gets an iterator over all VJOURNAL components
   */
  *getJournalIterator() {
    yield* this.getComponentIterator('vjournal');
  }

  /**
   * Gets an iterator over all VTODO components
   */
  *getTodoIterator() {
    yield* this.getComponentIterator('vtodo');
  }

  /**
   * @inheritDoc
   */
  static _getConstructorForComponentName(componentName) {
    return getConstructorForComponentName(componentName);
  }

  /**
   * Converts this calendar component into text/calendar
   *
   * @param {boolean} cleanUpTimezones Whether or not to clean up timezone data
   * @return {string}
   */
  toICS(cleanUpTimezones = true) {
    for (const vObject of this.getVObjectIterator()) {
      vObject.undirtify();
    }
    const icalRoot = this.toICALJs();
    if (cleanUpTimezones) {
      ICAL.helpers.updateTimezones(icalRoot);
    }
    return icalRoot.toString();
  }

  /**
   * Creates a new empty calendar-component
   *
   * @param {[string][]=} additionalProps Additional props to add to empty calendar-document
   * @return {CalendarComponent}
   */
  static fromEmpty(additionalProps = []) {
    return new this('VCALENDAR', [['prodid', getConfig('PRODID', '-//IDN georgehrke.com//calendar-js//EN')], ['calscale', 'GREGORIAN'], ['version', '2.0']].concat(additionalProps));
  }

  /**
   * Creates a new calendar-component with a method
   *
   * @param {string} method The method for the calendar-document
   * @return {CalendarComponent}
   */
  static fromMethod(method) {
    return this.fromEmpty([['method', method]]);
  }

  /**
   * @inheritDoc
   */
  static fromICALJs(icalValue) {
    const comp = super.fromICALJs(icalValue);
    comp.root = comp;
    return comp;
  }
}

/**
 * ProductId representing the software that created this calendar-document
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.3
 *
 * @name CalendarComponent#productId
 * @type {string}
 */
advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'productId',
  iCalendarName: 'PRODID'
});

/**
 * iCalendar version of this calendar-document
 * minver and maxver parameters are not supported, since they
 * are virtually used by no calendaring-software
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.4
 *
 * @name CalendarComponent#version
 * @type {string}
 */

advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'version'
});

/**
 * Calendar-scale used in this calendar-document
 * The default and only supported calendar-scale is GREGORIAN.
 * There is an iCalendar-extension about non-gregorian RRULES,
 * but that is not supported by calendar-js at the moment
 *
 * @see https://tools.ietf.org/html/rfc7529
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.1
 *
 * @name CalendarComponent#calendarScale
 * @type {string}
 * @default "GREGORIAN"
 */
advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'calendarScale',
  iCalendarName: 'CALSCALE',
  defaultValue: 'GREGORIAN'
});

/**
 * Method of this calendar-document when being used in an iTIP message
 * Please see https://tools.ietf.org/html/rfc5546#section-3.2 for more information
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.2
 *
 * @name CalendarComponent#method
 * @type {string}
 */
advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'method'
});

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractRepairStep
 * @classdesc A repair step is used to fix calendar-data before it is parsed
 */
class AbstractRepairStep {
  /**
   * @class
   */
  constructor() {
    if (new.target === AbstractRepairStep) {
      throw new TypeError('Cannot instantiate abstract class AbstractRepairStep');
    }
  }

  /**
   * @param {string} input String representation of the data to repair
   */
  repair(input) {
    throw new TypeError('Abstract method not implemented by subclass');
  }

  /**
   * @return {number}
   */
  static priority() {
    return 0;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarAddMissingUIDRepairStep
 */
class ICalendarAddMissingUIDRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^BEGIN:(VEVENT|VTODO|VJOURNAL)$(((?!^END:(VEVENT|VTODO|VJOURNAL)$)(?!^UID.*$)(.|\n))*)^END:(VEVENT|VTODO|VJOURNAL)$\n/gm, (match, vobjectName, vObjectBlock) => {
      return 'BEGIN:' + vobjectName + '\r\n' + 'UID:' + v4() + vObjectBlock + 'END:' + vobjectName + '\r\n';
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarAddMissingValueDateDoubleColonRepairStep
 */
class ICalendarAddMissingValueDateDoubleColonRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^(DTSTART|DTEND)(.*):([0-9]{8})T(::)$/gm, (match, propName, parameters, date) => {
      return propName + ';VALUE=DATE:' + date;
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarAddMissingValueDateRepairStep
 */
class ICalendarAddMissingValueDateRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^(DTSTART|DTEND|EXDATE)(((?!VALUE=DATE).)*):([0-9]{8})$/gm, (match, propName, parameters, _, date) => {
      return propName + parameters + ';VALUE=DATE:' + date;
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarEmptyTriggerRepairStep
 * @classdesc This repair step fixes malformed TRIGGER properties
 */
class ICalendarEmptyTriggerRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^TRIGGER:P$/gm, 'TRIGGER:P0D').replace(/^TRIGGER:-P$/gm, 'TRIGGER:P0D');
  }
}

/**
 * @copyright Copyright (c) 2020 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
class ICalendarIllegalCreatedRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^CREATED:00001231T000000Z$/gm, 'CREATED:19700101T000000Z');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarMultipleVCalendarBlocksRepairStep
 * @classdesc This repair step merges multiple BEGIN:VCALENDAR...END:VCALENDAR blocks
 */
class ICalendarMultipleVCalendarBlocksRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    let containsProdId = false;
    let containsVersion = false;
    let containsCalscale = false;
    const includedTimezones = new Set();
    return ics.replace(/^END:VCALENDAR$(((?!^BEGIN:)(.|\n))*)^BEGIN:VCALENDAR$\n/gm, '').replace(/^PRODID:(.*)$\n/gm, match => {
      if (containsProdId) {
        return '';
      }
      containsProdId = true;
      return match;
    }).replace(/^VERSION:(.*)$\n/gm, match => {
      if (containsVersion) {
        return '';
      }
      containsVersion = true;
      return match;
    }).replace(/^CALSCALE:(.*)$\n/gm, match => {
      if (containsCalscale) {
        return '';
      }
      containsCalscale = true;
      return match;
    }).replace(/^BEGIN:VTIMEZONE$(((?!^END:VTIMEZONE$)(.|\n))*)^END:VTIMEZONE$\n/gm, match => {
      const tzidMatcher = match.match(/^TZID:(.*)$/gm);

      // If this Timezone definition contains no TZID for some reason,
      // just remove it, because we can't use it anyway
      if (tzidMatcher === null) {
        return '';
      }
      const tzid = uc(tzidMatcher[0].slice(5));
      if (includedTimezones.has(tzid)) {
        // If we already included this timezone, just skip
        return '';
      }
      includedTimezones.add(tzid);
      return match;
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarRemoveXNCGroupIdRepairStep
 * @classdesc This repair step removes the X-NC-GroupID parameter used in previous versions of Nextcloud
 */
class ICalendarRemoveXNCGroupIdRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/(^.*)(;X-NC-GROUP-ID=\d+)(:.*$)/gm, '$1$3');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Get an iterator over all repair steps for iCalendar documents
 */
function* getRepairSteps() {
  yield ICalendarAddMissingUIDRepairStep;
  yield ICalendarAddMissingValueDateDoubleColonRepairStep;
  yield ICalendarAddMissingValueDateRepairStep;
  yield ICalendarEmptyTriggerRepairStep;
  yield ICalendarIllegalCreatedRepairStep;
  yield ICalendarMultipleVCalendarBlocksRepairStep;
  yield ICalendarRemoveXNCGroupIdRepairStep;
}

var version = "2.2023c";
var aliases = {
	"AUS Central Standard Time": {
		aliasTo: "Australia/Darwin"
	},
	"AUS Eastern Standard Time": {
		aliasTo: "Australia/Sydney"
	},
	"Afghanistan Standard Time": {
		aliasTo: "Asia/Kabul"
	},
	"Africa/Asmera": {
		aliasTo: "Africa/Asmara"
	},
	"Africa/Timbuktu": {
		aliasTo: "Africa/Bamako"
	},
	"Alaskan Standard Time": {
		aliasTo: "America/Anchorage"
	},
	"America/Argentina/ComodRivadavia": {
		aliasTo: "America/Argentina/Catamarca"
	},
	"America/Buenos_Aires": {
		aliasTo: "America/Argentina/Buenos_Aires"
	},
	"America/Louisville": {
		aliasTo: "America/Kentucky/Louisville"
	},
	"America/Montreal": {
		aliasTo: "America/Toronto"
	},
	"America/Santa_Isabel": {
		aliasTo: "America/Tijuana"
	},
	"Arab Standard Time": {
		aliasTo: "Asia/Riyadh"
	},
	"Arabian Standard Time": {
		aliasTo: "Asia/Dubai"
	},
	"Arabic Standard Time": {
		aliasTo: "Asia/Baghdad"
	},
	"Argentina Standard Time": {
		aliasTo: "America/Argentina/Buenos_Aires"
	},
	"Asia/Calcutta": {
		aliasTo: "Asia/Kolkata"
	},
	"Asia/Katmandu": {
		aliasTo: "Asia/Kathmandu"
	},
	"Asia/Rangoon": {
		aliasTo: "Asia/Yangon"
	},
	"Asia/Saigon": {
		aliasTo: "Asia/Ho_Chi_Minh"
	},
	"Atlantic Standard Time": {
		aliasTo: "America/Halifax"
	},
	"Atlantic/Faeroe": {
		aliasTo: "Atlantic/Faroe"
	},
	"Atlantic/Jan_Mayen": {
		aliasTo: "Europe/Oslo"
	},
	"Azerbaijan Standard Time": {
		aliasTo: "Asia/Baku"
	},
	"Azores Standard Time": {
		aliasTo: "Atlantic/Azores"
	},
	"Bahia Standard Time": {
		aliasTo: "America/Bahia"
	},
	"Bangladesh Standard Time": {
		aliasTo: "Asia/Dhaka"
	},
	"Belarus Standard Time": {
		aliasTo: "Europe/Minsk"
	},
	"Canada Central Standard Time": {
		aliasTo: "America/Regina"
	},
	"Cape Verde Standard Time": {
		aliasTo: "Atlantic/Cape_Verde"
	},
	"Caucasus Standard Time": {
		aliasTo: "Asia/Yerevan"
	},
	"Cen. Australia Standard Time": {
		aliasTo: "Australia/Adelaide"
	},
	"Central America Standard Time": {
		aliasTo: "America/Guatemala"
	},
	"Central Asia Standard Time": {
		aliasTo: "Asia/Almaty"
	},
	"Central Brazilian Standard Time": {
		aliasTo: "America/Cuiaba"
	},
	"Central Europe Standard Time": {
		aliasTo: "Europe/Budapest"
	},
	"Central European Standard Time": {
		aliasTo: "Europe/Warsaw"
	},
	"Central Pacific Standard Time": {
		aliasTo: "Pacific/Guadalcanal"
	},
	"Central Standard Time": {
		aliasTo: "America/Chicago"
	},
	"Central Standard Time (Mexico)": {
		aliasTo: "America/Mexico_City"
	},
	"China Standard Time": {
		aliasTo: "Asia/Shanghai"
	},
	"E. Africa Standard Time": {
		aliasTo: "Africa/Nairobi"
	},
	"E. Australia Standard Time": {
		aliasTo: "Australia/Brisbane"
	},
	"E. South America Standard Time": {
		aliasTo: "America/Sao_Paulo"
	},
	"Eastern Standard Time": {
		aliasTo: "America/New_York"
	},
	"Egypt Standard Time": {
		aliasTo: "Africa/Cairo"
	},
	"Ekaterinburg Standard Time": {
		aliasTo: "Asia/Yekaterinburg"
	},
	"Etc/GMT": {
		aliasTo: "UTC"
	},
	"Etc/GMT+0": {
		aliasTo: "UTC"
	},
	"Etc/UCT": {
		aliasTo: "UTC"
	},
	"Etc/UTC": {
		aliasTo: "UTC"
	},
	"Etc/Unversal": {
		aliasTo: "UTC"
	},
	"Etc/Zulu": {
		aliasTo: "UTC"
	},
	"Europe/Belfast": {
		aliasTo: "Europe/London"
	},
	"FLE Standard Time": {
		aliasTo: "Europe/Kiev"
	},
	"Fiji Standard Time": {
		aliasTo: "Pacific/Fiji"
	},
	GMT: {
		aliasTo: "UTC"
	},
	"GMT Standard Time": {
		aliasTo: "Europe/London"
	},
	"GMT+0": {
		aliasTo: "UTC"
	},
	GMT0: {
		aliasTo: "UTC"
	},
	"GTB Standard Time": {
		aliasTo: "Europe/Bucharest"
	},
	"Georgian Standard Time": {
		aliasTo: "Asia/Tbilisi"
	},
	"Greenland Standard Time": {
		aliasTo: "America/Godthab"
	},
	Greenwich: {
		aliasTo: "UTC"
	},
	"Greenwich Standard Time": {
		aliasTo: "Atlantic/Reykjavik"
	},
	"Hawaiian Standard Time": {
		aliasTo: "Pacific/Honolulu"
	},
	"India Standard Time": {
		aliasTo: "Asia/Calcutta"
	},
	"Iran Standard Time": {
		aliasTo: "Asia/Tehran"
	},
	"Israel Standard Time": {
		aliasTo: "Asia/Jerusalem"
	},
	"Jordan Standard Time": {
		aliasTo: "Asia/Amman"
	},
	"Kaliningrad Standard Time": {
		aliasTo: "Europe/Kaliningrad"
	},
	"Korea Standard Time": {
		aliasTo: "Asia/Seoul"
	},
	"Libya Standard Time": {
		aliasTo: "Africa/Tripoli"
	},
	"Line Islands Standard Time": {
		aliasTo: "Pacific/Kiritimati"
	},
	"Magadan Standard Time": {
		aliasTo: "Asia/Magadan"
	},
	"Mauritius Standard Time": {
		aliasTo: "Indian/Mauritius"
	},
	"Middle East Standard Time": {
		aliasTo: "Asia/Beirut"
	},
	"Montevideo Standard Time": {
		aliasTo: "America/Montevideo"
	},
	"Morocco Standard Time": {
		aliasTo: "Africa/Casablanca"
	},
	"Mountain Standard Time": {
		aliasTo: "America/Denver"
	},
	"Mountain Standard Time (Mexico)": {
		aliasTo: "America/Chihuahua"
	},
	"Myanmar Standard Time": {
		aliasTo: "Asia/Rangoon"
	},
	"N. Central Asia Standard Time": {
		aliasTo: "Asia/Novosibirsk"
	},
	"Namibia Standard Time": {
		aliasTo: "Africa/Windhoek"
	},
	"Nepal Standard Time": {
		aliasTo: "Asia/Katmandu"
	},
	"New Zealand Standard Time": {
		aliasTo: "Pacific/Auckland"
	},
	"Newfoundland Standard Time": {
		aliasTo: "America/St_Johns"
	},
	"North Asia East Standard Time": {
		aliasTo: "Asia/Irkutsk"
	},
	"North Asia Standard Time": {
		aliasTo: "Asia/Krasnoyarsk"
	},
	"Pacific SA Standard Time": {
		aliasTo: "America/Santiago"
	},
	"Pacific Standard Time": {
		aliasTo: "America/Los_Angeles"
	},
	"Pacific Standard Time (Mexico)": {
		aliasTo: "America/Santa_Isabel"
	},
	"Pacific/Johnston": {
		aliasTo: "Pacific/Honolulu"
	},
	"Pakistan Standard Time": {
		aliasTo: "Asia/Karachi"
	},
	"Paraguay Standard Time": {
		aliasTo: "America/Asuncion"
	},
	"Romance Standard Time": {
		aliasTo: "Europe/Paris"
	},
	"Russia Time Zone 10": {
		aliasTo: "Asia/Srednekolymsk"
	},
	"Russia Time Zone 11": {
		aliasTo: "Asia/Kamchatka"
	},
	"Russia Time Zone 3": {
		aliasTo: "Europe/Samara"
	},
	"Russian Standard Time": {
		aliasTo: "Europe/Moscow"
	},
	"SA Eastern Standard Time": {
		aliasTo: "America/Cayenne"
	},
	"SA Pacific Standard Time": {
		aliasTo: "America/Bogota"
	},
	"SA Western Standard Time": {
		aliasTo: "America/La_Paz"
	},
	"SE Asia Standard Time": {
		aliasTo: "Asia/Bangkok"
	},
	"Samoa Standard Time": {
		aliasTo: "Pacific/Apia"
	},
	"Singapore Standard Time": {
		aliasTo: "Asia/Singapore"
	},
	"South Africa Standard Time": {
		aliasTo: "Africa/Johannesburg"
	},
	"Sri Lanka Standard Time": {
		aliasTo: "Asia/Colombo"
	},
	"Syria Standard Time": {
		aliasTo: "Asia/Damascus"
	},
	"Taipei Standard Time": {
		aliasTo: "Asia/Taipei"
	},
	"Tasmania Standard Time": {
		aliasTo: "Australia/Hobart"
	},
	"Tokyo Standard Time": {
		aliasTo: "Asia/Tokyo"
	},
	"Tonga Standard Time": {
		aliasTo: "Pacific/Tongatapu"
	},
	"Turkey Standard Time": {
		aliasTo: "Europe/Istanbul"
	},
	UCT: {
		aliasTo: "UTC"
	},
	"US Eastern Standard Time": {
		aliasTo: "America/Indiana/Indianapolis"
	},
	"US Mountain Standard Time": {
		aliasTo: "America/Phoenix"
	},
	"US/Central": {
		aliasTo: "America/Chicago"
	},
	"US/Eastern": {
		aliasTo: "America/New_York"
	},
	"US/Mountain": {
		aliasTo: "America/Denver"
	},
	"US/Pacific": {
		aliasTo: "America/Los_Angeles"
	},
	"US/Pacific-New": {
		aliasTo: "America/Los_Angeles"
	},
	"Ulaanbaatar Standard Time": {
		aliasTo: "Asia/Ulaanbaatar"
	},
	Universal: {
		aliasTo: "UTC"
	},
	"Venezuela Standard Time": {
		aliasTo: "America/Caracas"
	},
	"Vladivostok Standard Time": {
		aliasTo: "Asia/Vladivostok"
	},
	"W. Australia Standard Time": {
		aliasTo: "Australia/Perth"
	},
	"W. Central Africa Standard Time": {
		aliasTo: "Africa/Lagos"
	},
	"W. Europe Standard Time": {
		aliasTo: "Europe/Berlin"
	},
	"West Asia Standard Time": {
		aliasTo: "Asia/Tashkent"
	},
	"West Pacific Standard Time": {
		aliasTo: "Pacific/Port_Moresby"
	},
	"Yakutsk Standard Time": {
		aliasTo: "Asia/Yakutsk"
	},
	Z: {
		aliasTo: "UTC"
	},
	Zulu: {
		aliasTo: "UTC"
	},
	utc: {
		aliasTo: "UTC"
	}
};
var zones = {
	"Africa/Abidjan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0051900",
		longitude: "-0040200"
	},
	"Africa/Accra": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Addis_Ababa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Algiers": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0364700",
		longitude: "+0030300"
	},
	"Africa/Asmara": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Asmera": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bamako": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bangui": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Banjul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bissau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0115100",
		longitude: "-0153500"
	},
	"Africa/Blantyre": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Brazzaville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bujumbura": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Cairo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700424T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=-1FR\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD"
		],
		latitude: "+0300300",
		longitude: "+0311500"
	},
	"Africa/Casablanca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0333900",
		longitude: "-0073500"
	},
	"Africa/Ceuta": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0355300",
		longitude: "-0051900"
	},
	"Africa/Conakry": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Dakar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Dar_es_Salaam": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Djibouti": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Douala": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/El_Aaiun": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0270900",
		longitude: "-0131200"
	},
	"Africa/Freetown": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Gaborone": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Harare": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Johannesburg": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0261500",
		longitude: "+0280000"
	},
	"Africa/Juba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0045100",
		longitude: "+0313700"
	},
	"Africa/Kampala": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Khartoum": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0153600",
		longitude: "+0323200"
	},
	"Africa/Kigali": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Kinshasa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lagos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0062700",
		longitude: "+0032400"
	},
	"Africa/Libreville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lome": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Luanda": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lubumbashi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lusaka": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Malabo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Maputo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0255800",
		longitude: "+0323500"
	},
	"Africa/Maseru": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Mbabane": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Mogadishu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Monrovia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0061800",
		longitude: "-0104700"
	},
	"Africa/Nairobi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0011700",
		longitude: "+0364900"
	},
	"Africa/Ndjamena": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0120700",
		longitude: "+0150300"
	},
	"Africa/Niamey": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Nouakchott": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Ouagadougou": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Porto-Novo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Sao_Tome": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0002000",
		longitude: "+0064400"
	},
	"Africa/Timbuktu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Tripoli": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0325400",
		longitude: "+0131100"
	},
	"Africa/Tunis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0364800",
		longitude: "+0101100"
	},
	"Africa/Windhoek": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0223400",
		longitude: "+0170600"
	},
	"America/Adak": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0515248",
		longitude: "-1763929"
	},
	"America/Anchorage": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0611305",
		longitude: "-1495401"
	},
	"America/Anguilla": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Antigua": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Araguaina": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0071200",
		longitude: "-0481200"
	},
	"America/Argentina/Buenos_Aires": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0343600",
		longitude: "-0582700"
	},
	"America/Argentina/Catamarca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0282800",
		longitude: "-0654700"
	},
	"America/Argentina/ComodRivadavia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Argentina/Cordoba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0312400",
		longitude: "-0641100"
	},
	"America/Argentina/Jujuy": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0241100",
		longitude: "-0651800"
	},
	"America/Argentina/La_Rioja": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0292600",
		longitude: "-0665100"
	},
	"America/Argentina/Mendoza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0325300",
		longitude: "-0684900"
	},
	"America/Argentina/Rio_Gallegos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0513800",
		longitude: "-0691300"
	},
	"America/Argentina/Salta": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0244700",
		longitude: "-0652500"
	},
	"America/Argentina/San_Juan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0313200",
		longitude: "-0683100"
	},
	"America/Argentina/San_Luis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0331900",
		longitude: "-0662100"
	},
	"America/Argentina/Tucuman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0264900",
		longitude: "-0651300"
	},
	"America/Argentina/Ushuaia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0544800",
		longitude: "-0681800"
	},
	"America/Aruba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Asuncion": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701004T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700322T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=4SU\r\nEND:STANDARD"
		],
		latitude: "-0251600",
		longitude: "-0574000"
	},
	"America/Atikokan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Atka": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Bahia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0125900",
		longitude: "-0383100"
	},
	"America/Bahia_Banderas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0204800",
		longitude: "-1051500"
	},
	"America/Barbados": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0130600",
		longitude: "-0593700"
	},
	"America/Belem": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0012700",
		longitude: "-0482900"
	},
	"America/Belize": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0173000",
		longitude: "-0881200"
	},
	"America/Blanc-Sablon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Boa_Vista": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0024900",
		longitude: "-0604000"
	},
	"America/Bogota": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0043600",
		longitude: "-0740500"
	},
	"America/Boise": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0433649",
		longitude: "-1161209"
	},
	"America/Buenos_Aires": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cambridge_Bay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0690650",
		longitude: "-1050310"
	},
	"America/Campo_Grande": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0202700",
		longitude: "-0543700"
	},
	"America/Cancun": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0210500",
		longitude: "-0864600"
	},
	"America/Caracas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0103000",
		longitude: "-0665600"
	},
	"America/Catamarca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cayenne": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0045600",
		longitude: "-0522000"
	},
	"America/Cayman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Chicago": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0415100",
		longitude: "-0873900"
	},
	"America/Chihuahua": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0283800",
		longitude: "-1060500"
	},
	"America/Ciudad_Juarez": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0314400",
		longitude: "-1062900"
	},
	"America/Coral_Harbour": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cordoba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Costa_Rica": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0095600",
		longitude: "-0840500"
	},
	"America/Creston": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cuiaba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0153500",
		longitude: "-0560500"
	},
	"America/Curacao": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Danmarkshavn": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0764600",
		longitude: "-0184000"
	},
	"America/Dawson": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0640400",
		longitude: "-1392500"
	},
	"America/Dawson_Creek": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0554600",
		longitude: "-1201400"
	},
	"America/Denver": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0394421",
		longitude: "-1045903"
	},
	"America/Detroit": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0421953",
		longitude: "-0830245"
	},
	"America/Dominica": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Edmonton": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0533300",
		longitude: "-1132800"
	},
	"America/Eirunepe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0064000",
		longitude: "-0695200"
	},
	"America/El_Salvador": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0134200",
		longitude: "-0891200"
	},
	"America/Ensenada": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Fort_Nelson": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0584800",
		longitude: "-1224200"
	},
	"America/Fort_Wayne": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Fortaleza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0034300",
		longitude: "-0383000"
	},
	"America/Glace_Bay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0461200",
		longitude: "-0595700"
	},
	"America/Godthab": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"America/Goose_Bay": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0532000",
		longitude: "-0602500"
	},
	"America/Grand_Turk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0212800",
		longitude: "-0710800"
	},
	"America/Grenada": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Guadeloupe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Guatemala": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0143800",
		longitude: "-0903100"
	},
	"America/Guayaquil": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0021000",
		longitude: "-0795000"
	},
	"America/Guyana": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0064800",
		longitude: "-0581000"
	},
	"America/Halifax": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0443900",
		longitude: "-0633600"
	},
	"America/Havana": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:CST\r\nDTSTART:19701101T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:CDT\r\nDTSTART:19700308T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0230800",
		longitude: "-0822200"
	},
	"America/Hermosillo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0290400",
		longitude: "-1105800"
	},
	"America/Indiana/Indianapolis": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0394606",
		longitude: "-0860929"
	},
	"America/Indiana/Knox": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0411745",
		longitude: "-0863730"
	},
	"America/Indiana/Marengo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0382232",
		longitude: "-0862041"
	},
	"America/Indiana/Petersburg": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0382931",
		longitude: "-0871643"
	},
	"America/Indiana/Tell_City": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0375711",
		longitude: "-0864541"
	},
	"America/Indiana/Vevay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0384452",
		longitude: "-0850402"
	},
	"America/Indiana/Vincennes": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0384038",
		longitude: "-0873143"
	},
	"America/Indiana/Winamac": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0410305",
		longitude: "-0863611"
	},
	"America/Indianapolis": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Inuvik": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0682059",
		longitude: "-1334300"
	},
	"America/Iqaluit": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0634400",
		longitude: "-0682800"
	},
	"America/Jamaica": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0175805",
		longitude: "-0764736"
	},
	"America/Jujuy": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Juneau": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0581807",
		longitude: "-1342511"
	},
	"America/Kentucky/Louisville": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0381515",
		longitude: "-0854534"
	},
	"America/Kentucky/Monticello": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0364947",
		longitude: "-0845057"
	},
	"America/Knox_IN": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Kralendijk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/La_Paz": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0163000",
		longitude: "-0680900"
	},
	"America/Lima": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0120300",
		longitude: "-0770300"
	},
	"America/Los_Angeles": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0340308",
		longitude: "-1181434"
	},
	"America/Louisville": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Lower_Princes": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Maceio": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0094000",
		longitude: "-0354300"
	},
	"America/Managua": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0120900",
		longitude: "-0861700"
	},
	"America/Manaus": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0030800",
		longitude: "-0600100"
	},
	"America/Marigot": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Martinique": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0143600",
		longitude: "-0610500"
	},
	"America/Matamoros": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0255000",
		longitude: "-0973000"
	},
	"America/Mazatlan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0231300",
		longitude: "-1062500"
	},
	"America/Mendoza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Menominee": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0450628",
		longitude: "-0873651"
	},
	"America/Merida": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0205800",
		longitude: "-0893700"
	},
	"America/Metlakatla": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0550737",
		longitude: "-1313435"
	},
	"America/Mexico_City": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0192400",
		longitude: "-0990900"
	},
	"America/Miquelon": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0470300",
		longitude: "-0562000"
	},
	"America/Moncton": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0460600",
		longitude: "-0644700"
	},
	"America/Monterrey": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0254000",
		longitude: "-1001900"
	},
	"America/Montevideo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0345433",
		longitude: "-0561245"
	},
	"America/Montreal": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Montserrat": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Nassau": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/New_York": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0404251",
		longitude: "-0740023"
	},
	"America/Nipigon": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Nome": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0643004",
		longitude: "-1652423"
	},
	"America/Noronha": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0035100",
		longitude: "-0322500"
	},
	"America/North_Dakota/Beulah": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0471551",
		longitude: "-1014640"
	},
	"America/North_Dakota/Center": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0470659",
		longitude: "-1011757"
	},
	"America/North_Dakota/New_Salem": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0465042",
		longitude: "-1012439"
	},
	"America/Nuuk": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0641100",
		longitude: "-0514400"
	},
	"America/Ojinaga": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0293400",
		longitude: "-1042500"
	},
	"America/Panama": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0085800",
		longitude: "-0793200"
	},
	"America/Pangnirtung": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Paramaribo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0055000",
		longitude: "-0551000"
	},
	"America/Phoenix": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0332654",
		longitude: "-1120424"
	},
	"America/Port-au-Prince": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0183200",
		longitude: "-0722000"
	},
	"America/Port_of_Spain": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Porto_Acre": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Porto_Velho": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0084600",
		longitude: "-0635400"
	},
	"America/Puerto_Rico": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0182806",
		longitude: "-0660622"
	},
	"America/Punta_Arenas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0530900",
		longitude: "-0705500"
	},
	"America/Rainy_River": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Rankin_Inlet": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0624900",
		longitude: "-0920459"
	},
	"America/Recife": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0080300",
		longitude: "-0345400"
	},
	"America/Regina": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0502400",
		longitude: "-1043900"
	},
	"America/Resolute": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0744144",
		longitude: "-0944945"
	},
	"America/Rio_Branco": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0095800",
		longitude: "-0674800"
	},
	"America/Rosario": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Santa_Isabel": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Santarem": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0022600",
		longitude: "-0545200"
	},
	"America/Santiago": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700405T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700906T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0332700",
		longitude: "-0704000"
	},
	"America/Santo_Domingo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0182800",
		longitude: "-0695400"
	},
	"America/Sao_Paulo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0233200",
		longitude: "-0463700"
	},
	"America/Scoresbysund": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0702900",
		longitude: "-0215800"
	},
	"America/Shiprock": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Sitka": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0571035",
		longitude: "-1351807"
	},
	"America/St_Barthelemy": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Johns": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0473400",
		longitude: "-0524300"
	},
	"America/St_Kitts": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Lucia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Thomas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Vincent": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Swift_Current": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0501700",
		longitude: "-1075000"
	},
	"America/Tegucigalpa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0140600",
		longitude: "-0871300"
	},
	"America/Thule": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0763400",
		longitude: "-0684700"
	},
	"America/Thunder_Bay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Tijuana": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0323200",
		longitude: "-1170100"
	},
	"America/Toronto": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0433900",
		longitude: "-0792300"
	},
	"America/Tortola": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Vancouver": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0491600",
		longitude: "-1230700"
	},
	"America/Virgin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Whitehorse": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0604300",
		longitude: "-1350300"
	},
	"America/Winnipeg": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0495300",
		longitude: "-0970900"
	},
	"America/Yakutat": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0593249",
		longitude: "-1394338"
	},
	"America/Yellowknife": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Antarctica/Casey": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0661700",
		longitude: "+1103100"
	},
	"Antarctica/Davis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0683500",
		longitude: "+0775800"
	},
	"Antarctica/DumontDUrville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Antarctica/Macquarie": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0543000",
		longitude: "+1585700"
	},
	"Antarctica/Mawson": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0673600",
		longitude: "+0625300"
	},
	"Antarctica/McMurdo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Antarctica/Palmer": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0644800",
		longitude: "-0640600"
	},
	"Antarctica/Rothera": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0673400",
		longitude: "-0680800"
	},
	"Antarctica/South_Pole": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Antarctica/Syowa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Antarctica/Troll": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0200\r\nTZNAME:+02\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "-0720041",
		longitude: "+0023206"
	},
	"Antarctica/Vostok": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Arctic/Longyearbyen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Asia/Aden": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Almaty": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0431500",
		longitude: "+0765700"
	},
	"Asia/Amman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0315700",
		longitude: "+0355600"
	},
	"Asia/Anadyr": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0644500",
		longitude: "+1772900"
	},
	"Asia/Aqtau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0443100",
		longitude: "+0501600"
	},
	"Asia/Aqtobe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0501700",
		longitude: "+0571000"
	},
	"Asia/Ashgabat": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0375700",
		longitude: "+0582300"
	},
	"Asia/Ashkhabad": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Atyrau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0470700",
		longitude: "+0515600"
	},
	"Asia/Baghdad": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0332100",
		longitude: "+0442500"
	},
	"Asia/Bahrain": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Baku": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0402300",
		longitude: "+0495100"
	},
	"Asia/Bangkok": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0134500",
		longitude: "+1003100"
	},
	"Asia/Barnaul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0532200",
		longitude: "+0834500"
	},
	"Asia/Beirut": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0335300",
		longitude: "+0353000"
	},
	"Asia/Bishkek": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0425400",
		longitude: "+0743600"
	},
	"Asia/Brunei": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Calcutta": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Chita": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0520300",
		longitude: "+1132800"
	},
	"Asia/Choibalsan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0480400",
		longitude: "+1143000"
	},
	"Asia/Chongqing": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Chungking": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Colombo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:+0530\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0065600",
		longitude: "+0795100"
	},
	"Asia/Dacca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Damascus": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0333000",
		longitude: "+0361800"
	},
	"Asia/Dhaka": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0234300",
		longitude: "+0902500"
	},
	"Asia/Dili": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0083300",
		longitude: "+1253500"
	},
	"Asia/Dubai": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0251800",
		longitude: "+0551800"
	},
	"Asia/Dushanbe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0383500",
		longitude: "+0684800"
	},
	"Asia/Famagusta": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0350700",
		longitude: "+0335700"
	},
	"Asia/Gaza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701031T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700328T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT"
		],
		latitude: "+0313000",
		longitude: "+0342800"
	},
	"Asia/Harbin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Hebron": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701031T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700328T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT"
		],
		latitude: "+0313200",
		longitude: "+0350542"
	},
	"Asia/Ho_Chi_Minh": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0104500",
		longitude: "+1064000"
	},
	"Asia/Hong_Kong": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:HKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0221700",
		longitude: "+1140900"
	},
	"Asia/Hovd": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0480100",
		longitude: "+0913900"
	},
	"Asia/Irkutsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0521600",
		longitude: "+1042000"
	},
	"Asia/Istanbul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Jakarta": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0061000",
		longitude: "+1064800"
	},
	"Asia/Jayapura": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:WIT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0023200",
		longitude: "+1404200"
	},
	"Asia/Jerusalem": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0314650",
		longitude: "+0351326"
	},
	"Asia/Kabul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0343100",
		longitude: "+0691200"
	},
	"Asia/Kamchatka": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0530100",
		longitude: "+1583900"
	},
	"Asia/Karachi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:PKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0245200",
		longitude: "+0670300"
	},
	"Asia/Kashgar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Kathmandu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0274300",
		longitude: "+0851900"
	},
	"Asia/Katmandu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Khandyga": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0623923",
		longitude: "+1353314"
	},
	"Asia/Kolkata": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0223200",
		longitude: "+0882200"
	},
	"Asia/Krasnoyarsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0560100",
		longitude: "+0925000"
	},
	"Asia/Kuala_Lumpur": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Kuching": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0013300",
		longitude: "+1102000"
	},
	"Asia/Kuwait": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Macao": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Macau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0221150",
		longitude: "+1133230"
	},
	"Asia/Magadan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0593400",
		longitude: "+1504800"
	},
	"Asia/Makassar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0050700",
		longitude: "+1192400"
	},
	"Asia/Manila": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:PST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0143500",
		longitude: "+1210000"
	},
	"Asia/Muscat": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Nicosia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0351000",
		longitude: "+0332200"
	},
	"Asia/Novokuznetsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0534500",
		longitude: "+0870700"
	},
	"Asia/Novosibirsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0550200",
		longitude: "+0825500"
	},
	"Asia/Omsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0550000",
		longitude: "+0732400"
	},
	"Asia/Oral": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0511300",
		longitude: "+0512100"
	},
	"Asia/Phnom_Penh": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Pontianak": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0000200",
		longitude: "+1092000"
	},
	"Asia/Pyongyang": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0390100",
		longitude: "+1254500"
	},
	"Asia/Qatar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0251700",
		longitude: "+0513200"
	},
	"Asia/Qostanay": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0531200",
		longitude: "+0633700"
	},
	"Asia/Qyzylorda": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0444800",
		longitude: "+0652800"
	},
	"Asia/Rangoon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Riyadh": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0243800",
		longitude: "+0464300"
	},
	"Asia/Saigon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Sakhalin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0465800",
		longitude: "+1424200"
	},
	"Asia/Samarkand": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0394000",
		longitude: "+0664800"
	},
	"Asia/Seoul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0373300",
		longitude: "+1265800"
	},
	"Asia/Shanghai": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0311400",
		longitude: "+1212800"
	},
	"Asia/Singapore": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0011700",
		longitude: "+1035100"
	},
	"Asia/Srednekolymsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0672800",
		longitude: "+1534300"
	},
	"Asia/Taipei": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0250300",
		longitude: "+1213000"
	},
	"Asia/Tashkent": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0412000",
		longitude: "+0691800"
	},
	"Asia/Tbilisi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0414300",
		longitude: "+0444900"
	},
	"Asia/Tehran": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0330\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0354000",
		longitude: "+0512600"
	},
	"Asia/Tel_Aviv": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Asia/Thimbu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Thimphu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0272800",
		longitude: "+0893900"
	},
	"Asia/Tokyo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:JST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0353916",
		longitude: "+1394441"
	},
	"Asia/Tomsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0563000",
		longitude: "+0845800"
	},
	"Asia/Ujung_Pandang": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Ulaanbaatar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0475500",
		longitude: "+1065300"
	},
	"Asia/Ulan_Bator": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Urumqi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0434800",
		longitude: "+0873500"
	},
	"Asia/Ust-Nera": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0643337",
		longitude: "+1431336"
	},
	"Asia/Vientiane": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Vladivostok": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0431000",
		longitude: "+1315600"
	},
	"Asia/Yakutsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0620000",
		longitude: "+1294000"
	},
	"Asia/Yangon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0164700",
		longitude: "+0961000"
	},
	"Asia/Yekaterinburg": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0565100",
		longitude: "+0603600"
	},
	"Asia/Yerevan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0401100",
		longitude: "+0443000"
	},
	"Atlantic/Azores": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0374400",
		longitude: "-0254000"
	},
	"Atlantic/Bermuda": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0321700",
		longitude: "-0644600"
	},
	"Atlantic/Canary": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0280600",
		longitude: "-0152400"
	},
	"Atlantic/Cape_Verde": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0145500",
		longitude: "-0233100"
	},
	"Atlantic/Faeroe": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Atlantic/Faroe": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0620100",
		longitude: "-0064600"
	},
	"Atlantic/Jan_Mayen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Atlantic/Madeira": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0323800",
		longitude: "-0165400"
	},
	"Atlantic/Reykjavik": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Atlantic/South_Georgia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0541600",
		longitude: "-0363200"
	},
	"Atlantic/St_Helena": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Atlantic/Stanley": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0514200",
		longitude: "-0575100"
	},
	"Australia/ACT": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Adelaide": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0345500",
		longitude: "+1383500"
	},
	"Australia/Brisbane": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0272800",
		longitude: "+1530200"
	},
	"Australia/Broken_Hill": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0315700",
		longitude: "+1412700"
	},
	"Australia/Canberra": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Currie": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Australia/Darwin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0122800",
		longitude: "+1305000"
	},
	"Australia/Eucla": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0845\r\nTZOFFSETTO:+0845\r\nTZNAME:+0845\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0314300",
		longitude: "+1285200"
	},
	"Australia/Hobart": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0425300",
		longitude: "+1471900"
	},
	"Australia/LHI": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Lindeman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0201600",
		longitude: "+1490000"
	},
	"Australia/Lord_Howe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0313300",
		longitude: "+1590500"
	},
	"Australia/Melbourne": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0374900",
		longitude: "+1445800"
	},
	"Australia/NSW": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/North": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Australia/Perth": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0315700",
		longitude: "+1155100"
	},
	"Australia/Queensland": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Australia/South": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Sydney": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0335200",
		longitude: "+1511300"
	},
	"Australia/Tasmania": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Australia/Victoria": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/West": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Australia/Yancowinna": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Brazil/Acre": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Brazil/DeNoronha": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Brazil/East": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Brazil/West": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Canada/Atlantic": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Central": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Eastern": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Mountain": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Newfoundland": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		]
	},
	"Canada/Pacific": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Saskatchewan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Canada/Yukon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Chile/Continental": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700405T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700906T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Chile/EasterIsland": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700404T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700905T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Amsterdam": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Andorra": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0423000",
		longitude: "+0013100"
	},
	"Europe/Astrakhan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0462100",
		longitude: "+0480300"
	},
	"Europe/Athens": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0375800",
		longitude: "+0234300"
	},
	"Europe/Belfast": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Belgrade": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0445000",
		longitude: "+0203000"
	},
	"Europe/Berlin": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0523000",
		longitude: "+0132200"
	},
	"Europe/Bratislava": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Brussels": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0505000",
		longitude: "+0042000"
	},
	"Europe/Bucharest": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0442600",
		longitude: "+0260600"
	},
	"Europe/Budapest": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0473000",
		longitude: "+0190500"
	},
	"Europe/Busingen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Chisinau": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0470000",
		longitude: "+0285000"
	},
	"Europe/Copenhagen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Dublin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:IST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0532000",
		longitude: "-0061500"
	},
	"Europe/Gibraltar": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0360800",
		longitude: "-0052100"
	},
	"Europe/Guernsey": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Helsinki": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0601000",
		longitude: "+0245800"
	},
	"Europe/Isle_of_Man": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Istanbul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0410100",
		longitude: "+0285800"
	},
	"Europe/Jersey": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Kaliningrad": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0544300",
		longitude: "+0203000"
	},
	"Europe/Kiev": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Kirov": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0583600",
		longitude: "+0493900"
	},
	"Europe/Kyiv": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0502600",
		longitude: "+0303100"
	},
	"Europe/Lisbon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0384300",
		longitude: "-0090800"
	},
	"Europe/Ljubljana": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/London": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0513030",
		longitude: "+0000731"
	},
	"Europe/Luxembourg": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Madrid": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0402400",
		longitude: "-0034100"
	},
	"Europe/Malta": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0355400",
		longitude: "+0143100"
	},
	"Europe/Mariehamn": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Minsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0535400",
		longitude: "+0273400"
	},
	"Europe/Monaco": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Moscow": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0554521",
		longitude: "+0373704"
	},
	"Europe/Nicosia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Oslo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Paris": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0485200",
		longitude: "+0022000"
	},
	"Europe/Podgorica": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Prague": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0500500",
		longitude: "+0142600"
	},
	"Europe/Riga": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0565700",
		longitude: "+0240600"
	},
	"Europe/Rome": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0415400",
		longitude: "+0122900"
	},
	"Europe/Samara": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0531200",
		longitude: "+0500900"
	},
	"Europe/San_Marino": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Sarajevo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Saratov": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0513400",
		longitude: "+0460200"
	},
	"Europe/Simferopol": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0445700",
		longitude: "+0340600"
	},
	"Europe/Skopje": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Sofia": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0424100",
		longitude: "+0231900"
	},
	"Europe/Stockholm": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Tallinn": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0592500",
		longitude: "+0244500"
	},
	"Europe/Tirane": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0412000",
		longitude: "+0195000"
	},
	"Europe/Tiraspol": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Ulyanovsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0542000",
		longitude: "+0482400"
	},
	"Europe/Uzhgorod": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Vaduz": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Vatican": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Vienna": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0481300",
		longitude: "+0162000"
	},
	"Europe/Vilnius": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0544100",
		longitude: "+0251900"
	},
	"Europe/Volgograd": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0484400",
		longitude: "+0442500"
	},
	"Europe/Warsaw": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0521500",
		longitude: "+0210000"
	},
	"Europe/Zagreb": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Zaporozhye": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Zurich": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0472300",
		longitude: "+0083200"
	},
	"Indian/Antananarivo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Chagos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0072000",
		longitude: "+0722500"
	},
	"Indian/Christmas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Cocos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Comoro": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Kerguelen": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Mahe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Maldives": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0041000",
		longitude: "+0733000"
	},
	"Indian/Mauritius": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0201000",
		longitude: "+0573000"
	},
	"Indian/Mayotte": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Reunion": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Mexico/BajaNorte": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Mexico/BajaSur": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Mexico/General": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Apia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0135000",
		longitude: "-1714400"
	},
	"Pacific/Auckland": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0365200",
		longitude: "+1744600"
	},
	"Pacific/Bougainville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0061300",
		longitude: "+1553400"
	},
	"Pacific/Chatham": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1245\r\nTZOFFSETTO:+1345\r\nTZNAME:+1345\r\nDTSTART:19700927T024500\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1345\r\nTZOFFSETTO:+1245\r\nTZNAME:+1245\r\nDTSTART:19700405T034500\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0435700",
		longitude: "-1763300"
	},
	"Pacific/Chuuk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Easter": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700404T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700905T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT"
		],
		latitude: "-0270900",
		longitude: "-1092600"
	},
	"Pacific/Efate": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0174000",
		longitude: "+1682500"
	},
	"Pacific/Enderbury": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Fakaofo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0092200",
		longitude: "-1711400"
	},
	"Pacific/Fiji": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0180800",
		longitude: "+1782500"
	},
	"Pacific/Funafuti": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Galapagos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0005400",
		longitude: "-0893600"
	},
	"Pacific/Gambier": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0900\r\nTZNAME:-09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0230800",
		longitude: "-1345700"
	},
	"Pacific/Guadalcanal": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0093200",
		longitude: "+1601200"
	},
	"Pacific/Guam": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0132800",
		longitude: "+1444500"
	},
	"Pacific/Honolulu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0211825",
		longitude: "-1575130"
	},
	"Pacific/Johnston": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Kanton": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0024700",
		longitude: "-1714300"
	},
	"Pacific/Kiritimati": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0015200",
		longitude: "-1572000"
	},
	"Pacific/Kosrae": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0051900",
		longitude: "+1625900"
	},
	"Pacific/Kwajalein": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0090500",
		longitude: "+1672000"
	},
	"Pacific/Majuro": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Marquesas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0930\r\nTZOFFSETTO:-0930\r\nTZNAME:-0930\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0090000",
		longitude: "-1393000"
	},
	"Pacific/Midway": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Nauru": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0003100",
		longitude: "+1665500"
	},
	"Pacific/Niue": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:-11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0190100",
		longitude: "-1695500"
	},
	"Pacific/Norfolk": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0290300",
		longitude: "+1675800"
	},
	"Pacific/Noumea": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0221600",
		longitude: "+1662700"
	},
	"Pacific/Pago_Pago": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0141600",
		longitude: "-1704200"
	},
	"Pacific/Palau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0072000",
		longitude: "+1342900"
	},
	"Pacific/Pitcairn": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:-08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0250400",
		longitude: "-1300500"
	},
	"Pacific/Pohnpei": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Ponape": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Port_Moresby": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0093000",
		longitude: "+1471000"
	},
	"Pacific/Rarotonga": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0211400",
		longitude: "-1594600"
	},
	"Pacific/Saipan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Samoa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Tahiti": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0173200",
		longitude: "-1493400"
	},
	"Pacific/Tarawa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0012500",
		longitude: "+1730000"
	},
	"Pacific/Tongatapu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0210800",
		longitude: "-1751200"
	},
	"Pacific/Truk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Wake": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Wallis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Yap": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"US/Alaska": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Aleutian": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Arizona": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"US/Central": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/East-Indiana": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Eastern": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Hawaii": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"US/Indiana-Starke": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Michigan": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Mountain": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Pacific": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Samoa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	}
};
var tzData = {
	version: version,
	aliases: aliases,
	zones: zones
};

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TimezoneManager
 */
class TimezoneManager {
  /**
   * Constructor
   */
  constructor() {
    /**
     * Map of aliases
     * Alias name => timezoneId
     *
     * @type {Map<string, string>}
     */
    this._aliases = new Map();

    /**
     * Map of Timezones
     * timezoneId => Timezone
     *
     * @type {Map<string, Timezone>}
     * @private
     */
    this._timezones = new Map();
  }

  /**
   * Gets a timezone for the given id
   *
   * @param {string} timezoneId The id of the timezone
   * @return {Timezone|null}
   */
  getTimezoneForId(timezoneId) {
    return this._getTimezoneForIdRec(timezoneId, 0);
  }
  _getTimezoneForIdRec(timezoneId, level) {
    if (this._timezones.has(timezoneId)) {
      return this._timezones.get(timezoneId);
    }
    if (level >= 20) {
      // too much recursion
      console.error('TimezoneManager.getTimezoneForIdRec() exceeds recursion limits');
      return null;
    }
    if (this._aliases.has(timezoneId)) {
      const resolvedTimezoneId = this._aliases.get(timezoneId);
      // can be a recursive alias:
      return this._getTimezoneForIdRec(resolvedTimezoneId, level + 1);
    }
    return null;
  }

  /**
   * Checks if there is a timezone for the given id stored in this manager
   *
   * @param {string} timezoneId The id of the timezone
   * @return {boolean}
   */
  hasTimezoneForId(timezoneId) {
    return this._timezones.has(timezoneId) || this._aliases.has(timezoneId);
  }

  /**
   * Checks if the given timezone id is an alias
   *
   * @param {string} timezoneId The id of the timezone
   * @return {boolean}
   */
  isAlias(timezoneId) {
    return !this._timezones.has(timezoneId) && this._aliases.has(timezoneId);
  }

  /**
   * Lists all timezones
   *
   * @param {boolean=} includeAliases Whether or not to include aliases
   * @return {string[]}
   */
  listAllTimezones(includeAliases = false) {
    const timezones = Array.from(this._timezones.keys());
    if (includeAliases) {
      return timezones.concat(Array.from(this._aliases.keys()));
    }
    return timezones;
  }

  /**
   * Registers a timezone
   *
   * @param {Timezone} timezone The timezone-object to register
   */
  registerTimezone(timezone) {
    this._timezones.set(timezone.timezoneId, timezone);
  }
  registerDefaultTimezones() {
    console.debug(`@nextcloud/calendar-js app is using version ${tzData.version} of the timezone database`);
    for (const tzid in tzData.zones) {
      if (Object.prototype.hasOwnProperty.call(tzData.zones, [tzid])) {
        const ics = ['BEGIN:VTIMEZONE', 'TZID:' + tzid, ...tzData.zones[tzid].ics, 'END:VTIMEZONE'].join('\r\n');
        this.registerTimezoneFromICS(tzid, ics);
      }
    }
    for (const tzid in tzData.aliases) {
      if (Object.prototype.hasOwnProperty.call(tzData.aliases, [tzid])) {
        this.registerAlias(tzid, tzData.aliases[tzid].aliasTo);
      }
    }
  }

  /**
   * Registers a timezone based on ics data
   *
   * @param {string} timezoneId The id of the timezone
   * @param {string} ics The iCalendar timezone definition
   */
  registerTimezoneFromICS(timezoneId, ics) {
    const timezone = new Timezone(timezoneId, ics);
    this.registerTimezone(timezone);
  }

  /**
   * Registers a new timezone-alias
   *
   * @param {string} aliasName The timezone-id of the alias
   * @param {string} timezoneId The timezone-id to resolve the alias to
   */
  registerAlias(aliasName, timezoneId) {
    this._aliases.set(aliasName, timezoneId);
  }

  /**
   * Unregisters a timezone
   *
   * @param {string} timezoneId Unregisters a timezone by Id
   */
  unregisterTimezones(timezoneId) {
    this._timezones.delete(timezoneId);
  }

  /**
   * Unregisters a timezone-alias
   *
   * @param {string} aliasName The alias to unregister
   */
  unregisterAlias(aliasName) {
    this._aliases.delete(aliasName);
  }

  /**
   * Clear all timezones
   */
  clearAllTimezones() {
    this._aliases = new Map();
    this._timezones = new Map();
    timezoneManager.registerTimezone(Timezone.utc);
    timezoneManager.registerTimezone(Timezone.floating);
    timezoneManager.registerAlias('GMT', Timezone.utc.timezoneId);
    timezoneManager.registerAlias('Z', Timezone.utc.timezoneId);
  }
}
const timezoneManager = new TimezoneManager();
timezoneManager.clearAllTimezones();

/**
 * Gets the default instance of the timezone manager
 *
 * @return {TimezoneManager}
 */
function getTimezoneManager() {
  return timezoneManager;
}

/**
 *
 * @param {string} tzName Name of the timezone to check
 * @return {boolean}
 */
function isOlsonTimezone(tzName) {
  const hasSlash = tzName.indexOf('/') !== -1;
  const hasSpace = tzName.indexOf(' ') !== -1;
  const startsWithETC = tzName.startsWith('Etc');
  const startsWithUS = tzName.startsWith('US/');
  return hasSlash && !hasSpace && !startsWithETC && !startsWithUS;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarParser
 * @classdesc
 */
class ICalendarParser extends AbstractParser {
  /**
   * @inheritDoc
   */
  constructor(...args) {
    super(...args);

    /**
     * The raw text/calendar data
     *
     * @type {string}
     * @protected
     */
    this._rawData = null;

    /**
     * The CalendarComponent representing the raw data
     *
     * @type {CalendarComponent}
     * @protected
     */
    this._calendarComponent = null;

    /**
     * A flag whether this calendar-data contains vevents
     *
     * @type {boolean}
     * @private
     */
    this._containsVEvents = false;

    /**
     * A flag whether this calendar-data contains vjournals
     *
     * @type {boolean}
     * @private
     */
    this._containsVJournals = false;

    /**
     * A flag whether this calendar-data contains vtodos
     *
     * @type {boolean}
     * @private
     */
    this._containsVTodos = false;

    /**
     * A flag whether this calendar-data contains vfreebusy
     *
     * @type {boolean}
     * @private
     */
    this._containsVFreeBusy = false;

    /**
     * A map containing all VObjects.
     * The key of this map is the UID
     * The value an array of all VObjects with that particular UID
     *
     * @type {Map<string, AbstractRecurringComponent[]>}
     * @private
     */
    this._items = new Map();

    /**
     * Items that are no recurrence-exceptions
     * The key of this map is the UID
     *
     * @type {Map<string, AbstractRecurringComponent>}
     * @private
     */
    this._masterItems = new Map();

    /**
     * Items that are recurrence exceptions
     *
     * @type {Map<string, AbstractRecurringComponent[]>}
     * @private
     */
    this._recurrenceExceptionItems = new Map();

    /**
     * Some recurrence-exceptions come without a master item
     * In that case we need to forge a master item
     *
     * @type {Map<string, AbstractRecurringComponent>}
     * @private
     */
    this._forgedMasterItems = new Map();

    /**
     * A list of timezone-components found in the calendar-data
     *
     * @type {Map<string, Timezone>}
     * @private
     */
    this._timezones = new Map();

    /**
     * A set of required timezones for each UID
     *
     * @type {Map<string, Set<string>>}
     * @private
     */
    this._requiredTimezones = new Map();

    /**
     * Instance of the default timezone-manager
     *
     * @type {TimezoneManager}
     * @private
     */
    this._defaultTimezoneManager = getTimezoneManager();
  }

  /**
   * Parses the actual calendar-data
   *
   * @param {string} ics The icalendar data to parse
   */
  parse(ics) {
    this._rawData = ics;
    this._applyRepairSteps();

    // If a timezone is not inside our TimezoneManager at the time of parsing
    // the internal zone will be marked as floating inside ICAL.Time
    // so before we start any actual parsing, we need to extract all timezones
    // and add them to the TimezoneManager
    this._extractTimezones();
    this._registerTimezones();
    this._createCalendarComponent();
    if (this._getOption('extractGlobalProperties', false)) {
      this._extractProperties();
    }
    this._processVObjects();
    if (this._getOption('processFreeBusy', false)) {
      this._processVFreeBusy();
    }
  }

  /**
   * @inheritDoc
   */
  *getItemIterator() {
    for (const itemList of this._items.values()) {
      const calendarComp = CalendarComponent.fromEmpty();
      if (this._getOption('includeTimezones', false)) {
        this._addRequiredTimezonesToCalendarComp(calendarComp, itemList[0].uid);
      }

      // Preserve the original product id, just in case we need special handling for certain clients later on ...
      if (this._calendarComponent.hasProperty('PRODID')) {
        calendarComp.deleteAllProperties('PRODID');
        calendarComp.addProperty(this._calendarComponent.getFirstProperty('PRODID').clone());
      }
      if (this._getOption('preserveMethod', false)) {
        if (this._calendarComponent.hasProperty('METHOD')) {
          calendarComp.deleteAllProperties('METHOD');
          calendarComp.addProperty(this._calendarComponent.getFirstProperty('METHOD').clone());
        }
      }
      for (const item of itemList) {
        calendarComp.addComponent(item);
      }
      yield calendarComp;
    }
  }

  /**
   * @inheritDoc
   */
  containsVEvents() {
    return this._containsVEvents;
  }

  /**
   * @inheritDoc
   */
  containsVJournals() {
    return this._containsVJournals;
  }

  /**
   * @inheritDoc
   */
  containsVTodos() {
    return this._containsVTodos;
  }

  /**
   * @inheritDoc
   */
  containsVFreeBusy() {
    return this._containsVFreeBusy;
  }

  /**
   * @inheritDoc
   */
  getItemCount() {
    return Array.from(this._items.keys()).length;
  }

  /**
   * Applies all registered repair steps
   *
   * @private
   */
  _applyRepairSteps() {
    for (const RepairStep of getRepairSteps()) {
      const step = new RepairStep();
      this._rawData = step.repair(this._rawData);
    }
  }

  /**
   * Creates a calendar component based upon the repaired data
   *
   * @private
   */
  _createCalendarComponent() {
    const jCal = ICAL.parse(this._rawData);
    const icalComp = new ICAL.Component(jCal);
    this._calendarComponent = CalendarComponent.fromICALJs(icalComp);
  }

  /**
   * extracts properties
   *
   * @protected
   */
  _extractProperties() {
    this._extractPropertyAndPutResultIntoVariable(['name', 'x-wr-calname'], '_name');
    this._extractPropertyAndPutResultIntoVariable(['color', 'x-apple-calendar-color'], '_color');
    this._extractPropertyAndPutResultIntoVariable(['source'], '_sourceURL');
    this._extractPropertyAndPutResultIntoVariable(['refresh-interval', 'x-published-ttl'], '_refreshInterval');
    this._extractPropertyAndPutResultIntoVariable(['x-wr-timezone'], '_calendarTimezone');
  }

  /**
   * Extract a property and writes it into a class property
   * names must be an array, it will use the value of the fist
   * propertyname it can find
   *
   * @param {string[]} names The names of the properties to check
   * @param {string} variableName The variable name to save it under
   * @private
   */
  _extractPropertyAndPutResultIntoVariable(names, variableName) {
    for (const name of names) {
      if (this._calendarComponent.hasProperty(name)) {
        this[variableName] = this._calendarComponent.getFirstPropertyFirstValue(name);
        return;
      }
    }
  }

  /**
   * Extracts timezones from the calendar component
   *
   * @protected
   */
  _extractTimezones() {
    const matches = this._rawData.match(/^BEGIN:VTIMEZONE$(((?!^END:VTIMEZONE$)(.|\n))*)^END:VTIMEZONE$\n/gm);
    if (!matches) {
      return;
    }
    for (const match of matches) {
      const tzidMatcher = match.match(/^TZID:(.*)$/gm);
      if (!tzidMatcher) {
        continue;
      }
      const tzid = tzidMatcher[0].slice(5);
      const timezone = new Timezone(tzid, match);
      this._timezones.set(tzid, timezone);
    }
  }

  /**
   * Registers unknown timezones into our timezone-manager
   *
   * @protected
   */
  _registerTimezones() {
    for (const [tzid, timezone] of this._timezones) {
      if (!this._defaultTimezoneManager.hasTimezoneForId(tzid)) {
        this._defaultTimezoneManager.registerTimezone(timezone);
      }
    }
  }

  /**
   * Processes the parsed vobjects
   *
   * @protected
   */
  _processVObjects() {
    for (const vObject of this._calendarComponent.getVObjectIterator()) {
      this._addItem(vObject);
      this._markCompTypeAsSeen(vObject.name);
      if (vObject.isRecurrenceException()) {
        this._addRecurrenceException(vObject);
      } else {
        vObject.recurrenceManager = new RecurrenceManager(vObject);
        this._masterItems.set(vObject.uid, vObject);
      }
      for (const propertyToCheck of vObject.getPropertyIterator()) {
        for (const value of propertyToCheck.getValueIterator()) {
          if (value instanceof DateTimeValue && value.timezoneId) {
            this._addRequiredTimezone(vObject.uid, value.timezoneId);
          }
        }
      }

      // TRIGGER is supposed to be stored in UTC only,
      // but not all clients stick to this
      for (const alarm of vObject.getAlarmIterator()) {
        for (const propertyToCheck of alarm.getPropertyIterator()) {
          for (const value of propertyToCheck.getValueIterator()) {
            if (value instanceof DateTimeValue && value.timezoneId) {
              this._addRequiredTimezone(vObject.uid, value.timezoneId);
            }
          }
        }
      }
      if (this._getOption('removeRSVPForAttendees', false)) {
        for (const attendee of vObject.getAttendeeIterator()) {
          attendee.deleteParameter('RSVP');
        }
      }
    }
    for (const recurrenceExceptionList of this._recurrenceExceptionItems.values()) {
      for (const recurrenceException of recurrenceExceptionList) {
        // Check if there is a master item for this recurrence exception
        // otherwise we have to forge one
        if (!this._masterItems.has(recurrenceException.uid)) {
          const constructor = getConstructorForComponentName(recurrenceException.name);
          const forgedMaster = new constructor(recurrenceException.name, [['UID', recurrenceException.uid], ['DTSTAMP', recurrenceException.stampTime.clone()], ['DTSTART', recurrenceException.recurrenceId.clone()]]);
          forgedMaster.recurrenceManager = new RecurrenceManager(forgedMaster);
          this._forgedMasterItems.set(recurrenceException.uid, forgedMaster);
          this._masterItems.set(recurrenceException.uid, forgedMaster);
          this._addItem(forgedMaster);
        } else {
          const master = this._masterItems.get(recurrenceException.uid);

          // This should usually not be the case,
          // only if the calendar-data is seriously broken.
          // Let's try to handle it anyway by adding it to
          // forgedMasterItems, we will simply add RDATEs
          // in the next step to make it recur
          if (!master.isRecurring()) {
            this._forgedMasterItems.set(master.uid, master);
          }
        }
        if (this._forgedMasterItems.has(recurrenceException.uid)) {
          const forgedMaster = this._forgedMasterItems.get(recurrenceException.uid);
          forgedMaster.recurrenceManager.addRecurrenceDate(false, recurrenceException.recurrenceId.clone());
        }
        const masterItem = this._masterItems.get(recurrenceException.uid);
        masterItem.recurrenceManager.relateRecurrenceException(recurrenceException);
      }
    }
  }

  /**
   * Process FreeBusy components
   *
   * @private
   */
  _processVFreeBusy() {
    for (const vObject of this._calendarComponent.getFreebusyIterator()) {
      this._addItem(vObject);
      this._markCompTypeAsSeen(vObject.name);
      for (const propertyToCheck of vObject.getPropertyIterator()) {
        for (const value of propertyToCheck.getValueIterator()) {
          if (value instanceof DateTimeValue && value.timezoneId) {
            this._addRequiredTimezone(vObject.uid, value.timezoneId);
          }
        }
      }
    }
  }

  /**
   *
   * @param {AbstractRecurringComponent} item The recurrence-item to register
   * @private
   */
  _addRecurrenceException(item) {
    if (this._recurrenceExceptionItems.has(item.uid)) {
      const arr = this._recurrenceExceptionItems.get(item.uid);
      arr.push(item);
    } else {
      this._recurrenceExceptionItems.set(item.uid, [item]);
    }
  }

  /**
   *
   * @param {AbstractRecurringComponent} item The item to register
   * @private
   */
  _addItem(item) {
    if (this._items.has(item.uid)) {
      const arr = this._items.get(item.uid);
      arr.push(item);
    } else {
      this._items.set(item.uid, [item]);
    }
  }

  /**
   *
   * @param {string} uid The uid of the calendar-object
   * @param {string} timezoneId The timezoneId required by the object
   * @private
   */
  _addRequiredTimezone(uid, timezoneId) {
    if (timezoneId === 'UTC' || timezoneId === 'floating' || timezoneId === 'GMT' || timezoneId === 'Z') {
      return;
    }
    if (this._requiredTimezones.has(uid)) {
      this._requiredTimezones.get(uid).add(timezoneId);
    } else {
      const set = new Set([timezoneId]);
      this._requiredTimezones.set(uid, set);
    }
  }

  /**
   *
   * @param {CalendarComponent} calendarComp The calendar-component to add timezones to
   * @param {string} uid The UID of the calendar-object
   * @private
   */
  _addRequiredTimezonesToCalendarComp(calendarComp, uid) {
    if (!this._requiredTimezones.has(uid)) {
      return;
    }
    for (const requiredTimezone of this._requiredTimezones.get(uid)) {
      if (!this._defaultTimezoneManager.hasTimezoneForId(requiredTimezone)) {
        return;
      }
      const timezone = this._defaultTimezoneManager.getTimezoneForId(requiredTimezone);
      // Is this an alias?
      if (timezone.timezoneId !== requiredTimezone) {
        this._replaceTimezoneWithAnotherOne(calendarComp, requiredTimezone, timezone.timezoneId);
      }
      const timezoneComponent = TimezoneComponent.fromICALJs(timezone.toICALJs());
      calendarComp.addComponent(timezoneComponent);
    }
  }

  /**
   * Replaces all occurrences of searchTimezone with replaceTimezone
   *
   * @param {CalendarComponent} calendarComponent The calendar-component to replace a timezone in
   * @param {string} searchTimezone The timezone to replace
   * @param {string} replaceTimezone The replacement timezone
   * @private
   */
  _replaceTimezoneWithAnotherOne(calendarComponent, searchTimezone, replaceTimezone) {
    for (const vObject of this._calendarComponent.getVObjectIterator()) {
      for (const propertyToCheck of vObject.getPropertyIterator()) {
        for (const value of propertyToCheck.getValueIterator()) {
          if (!(value instanceof DateTimeValue)) {
            continue;
          }
          if (value.timezoneId === searchTimezone) {
            value.silentlyReplaceTimezone(replaceTimezone);
          }
        }
      }

      // TRIGGER is supposed to be stored in UTC only,
      // but not all clients stick to this
      for (const alarm of vObject.getAlarmIterator()) {
        for (const propertyToCheck of alarm.getPropertyIterator()) {
          for (const value of propertyToCheck.getValueIterator()) {
            if (!(value instanceof DateTimeValue)) {
              continue;
            }
            if (value.timezoneId === searchTimezone) {
              value.silentlyReplaceTimezone(replaceTimezone);
            }
          }
        }
      }
    }
  }

  /**
   * Marks a certain component type as seen.
   * This is used for
   * containsVEvents()
   * containsVJournals()
   * containsVTodos()
   *
   * @param {string} compName The name of the visited component
   * @private
   */
  _markCompTypeAsSeen(compName) {
    switch (uc(compName)) {
      case 'VEVENT':
        this._containsVEvents = true;
        break;
      case 'VJOURNAL':
        this._containsVJournals = true;
        break;
      case 'VTODO':
        this._containsVTodos = true;
        break;
      case 'VFREEBUSY':
        this._containsVFreeBusy = true;
        break;
    }
  }

  /**
   * @inheritDoc
   */
  static getMimeTypes() {
    return ['text/calendar'];
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ParserManager
 * @classdesc
 */
class ParserManager {
  /**
   * Constructor
   */
  constructor() {
    /**
     * List of supported parsers
     *
     * @type {Function[]}
     */
    this._parsers = [];
  }

  /**
   * Get a list of all supported file-types
   *
   * @return {string[]}
   */
  getAllSupportedFileTypes() {
    return this._parsers.reduce((allFileTypes, parser) => allFileTypes.concat(parser.getMimeTypes()), []);
  }

  /**
   * Get an instance of a parser for one specific file-type
   *
   * @param {string} fileType The mime-type to get a parser for
   * @param {object=} options Options destructuring object
   * @param {boolean=} options.extractGlobalProperties Whether or not to preserve properties from the VCALENDAR component (defaults to false)
   * @param {boolean=} options.removeRSVPForAttendees Whether or not to remove RSVP from attendees (defaults to false)
   * @param {boolean=} options.includeTimezones Whether or not to include timezones (defaults to false)
   * @param {boolean=} options.preserveMethod Whether or not to preserve the iCalendar method (defaults to false)
   * @param {boolean=} options.processFreeBusy Whether or not to process VFreeBusy components (defaults to false)
   *
   * @return {AbstractParser}
   */
  getParserForFileType(fileType, options) {
    const Parser = this._parsers.find(parser => parser.getMimeTypes().includes(fileType));
    if (!Parser) {
      throw new TypeError('Unknown file-type.');
    }
    return new Parser(options);
  }

  /**
   * Registers a parser
   *
   * @param {Function} parser The parser to register
   */
  registerParser(parser) {
    this._parsers.push(parser);
  }
}

/**
 * Gets an instance of the ParserManager with all default parsers
 *
 * @return {ParserManager}
 */
function getParserManager() {
  const parserManager = new ParserManager();

  // We only support iCalendar for now.
  // JSON calendar and CSV will be supported soon,
  // but require some more work

  parserManager.registerParser(ICalendarParser);
  // parserManager.registerParser(JCalendarParser)
  // parserManager.registerParser(CSVParser)

  return parserManager;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TimezoneAdapter
 * @classdesc Connecting ICAL.TimezoneService with our TimezoneManager
 */
class TimezoneAdapter {
  /**
   * Constructor
   *
   * @param {TimezoneManager} timezoneManager The timezone-manager to wrap
   */
  constructor(timezoneManager) {
    /**
     * TimezoneManager object
     *
     * @type {TimezoneManager}
     * @private
     */
    this._timezoneManager = timezoneManager;
  }

  /**
   * @param {string} timezoneId The id of the timezone
   * @return {boolean}
   */
  has(timezoneId) {
    return this._timezoneManager.hasTimezoneForId(timezoneId);
  }

  /**
   * @param {string} timezoneId The id of the timezone
   * @return {ICAL.Timezone|undefined}
   */
  get(timezoneId) {
    const timezone = this._timezoneManager.getTimezoneForId(timezoneId);
    if (!timezone) {
      return undefined;
    }
    return timezone.toICALTimezone();
  }

  /**
   * @throws TypeError
   */
  register() {
    throw new TypeError('Not allowed to register new timezone');
  }

  /**
   * @throws TypeError
   */
  remove() {
    throw new TypeError('Not allowed to remove timezone');
  }

  /**
   * @throws TypeError
   */
  reset() {
    throw new TypeError('Not allowed to reset TimezoneService');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class IllegalValueError extends Error {}

/**
 * @copyright Copyright (c) 2021 Christoph Wurst
 *
 * @author Christoph Wurst <christoph@winzerhof-wurst.at>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param {string[]} timezoneList List of Olsen timezones
 * @param {Array} additionalTimezones List of additional timezones
 * @param {string} globalTimezoneName The localized name of the "Global" timezones
 * @return {[]}
 */
function getSortedTimezoneList(timezoneList = [], additionalTimezones = [], globalTimezoneName = 'Global') {
  const sortedByContinent = {};
  const sortedList = [];
  for (const timezoneId of timezoneList) {
    const components = timezoneId.split('/');
    let [continent, name] = [components.shift(), components.join('/')];
    if (!name) {
      name = continent;
      continent = globalTimezoneName;
    }
    sortedByContinent[continent] = sortedByContinent[continent] || {
      continent,
      regions: []
    };
    sortedByContinent[continent].regions.push({
      label: getReadableTimezoneName(name),
      cities: [],
      timezoneId
    });
  }
  for (const additionalTimezone of additionalTimezones) {
    const {
      continent,
      label,
      timezoneId
    } = additionalTimezone;
    sortedByContinent[continent] = sortedByContinent[continent] || {
      continent,
      regions: []
    };
    sortedByContinent[continent].regions.push({
      label,
      cities: [],
      timezoneId
    });
  }
  for (const continent in sortedByContinent) {
    if (!Object.prototype.hasOwnProperty.call(sortedByContinent, continent)) {
      continue;
    }
    sortedByContinent[continent].regions.sort((a, b) => {
      if (a.label < b.label) {
        return -1;
      }
      return 1;
    });
    sortedList.push(sortedByContinent[continent]);
  }

  // Sort continents by name
  sortedList.sort((a, b) => {
    if (a.continent < b.continent) {
      return -1;
    }
    return 1;
  });
  return sortedList;
}

/**
 * Get human-readable name for timezoneId
 *
 * @param {string} timezoneId TimezoneId to turn human-readable
 * @return {string}
 */
function getReadableTimezoneName(timezoneId) {
  return timezoneId.split('_').join(' ').replace('St ', 'St. ').split('/').join(' - ');
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
if (!(ICAL.TimezoneService instanceof TimezoneAdapter)) {
  ICAL.TimezoneService = new TimezoneAdapter(getTimezoneManager());
}

/**
 * parses a single ICS and returns an iterator over all occurrences
 * in a given timeframe
 *
 * @param {string} ics The calendar-data to parse
 * @param {DateTimeValue} start The start of the queried time-range
 * @param {DateTimeValue} end The end of the queried time-range
 */
function* parseICSAndGetAllOccurrencesBetween(ics, start, end) {
  const parserManager = getParserManager();
  const icsParser = parserManager.getParserForFileType('text/calendar');
  icsParser.parse(ics);
  const objectIterator = icsParser.getItemIterator();
  const calendarComp = objectIterator.next().value;
  if (calendarComp === undefined) {
    return;
  }
  const vObjectIterator = calendarComp.getVObjectIterator();
  const firstVObject = vObjectIterator.next().value;
  if (firstVObject === undefined) {
    return;
  }
  yield* firstVObject.recurrenceManager.getAllOccurrencesBetweenIterator(start, end);
}

/**
 * Creates a new event
 *
 * @param {DateTimeValue} start Start-time of the new event
 * @param {DateTimeValue} end End-time of the new event
 * @return {CalendarComponent}
 */
function createEvent(start, end) {
  const calendar = CalendarComponent.fromEmpty();
  const eventComponent = new EventComponent('VEVENT');
  eventComponent.updatePropertyWithValue('CREATED', DateTimeValue.fromJSDate(dateFactory(), true));
  eventComponent.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
  eventComponent.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
  eventComponent.updatePropertyWithValue('SEQUENCE', 0);
  eventComponent.updatePropertyWithValue('UID', v4());
  eventComponent.updatePropertyWithValue('DTSTART', start);
  eventComponent.updatePropertyWithValue('DTEND', end);
  calendar.addComponent(eventComponent);
  eventComponent.recurrenceManager = new RecurrenceManager(eventComponent);
  return calendar;
}

/**
 * Creates a FreeBusy Request to be used on the scheduling outbox
 *
 * @param {DateTimeValue} start The start of the queried time-range
 * @param {DateTimeValue} end The end of the queried time-range
 * @param {AttendeeProperty} organizer The organizer querying information
 * @param {AttendeeProperty[]}attendees The list of attendees to query information for
 * @return {CalendarComponent}
 */
function createFreeBusyRequest(start, end, organizer, attendees) {
  const calendar = CalendarComponent.fromMethod('REQUEST');
  const freeBusyComponent = new FreeBusyComponent('VFREEBUSY');
  freeBusyComponent.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
  freeBusyComponent.updatePropertyWithValue('UID', v4());
  freeBusyComponent.updatePropertyWithValue('DTSTART', start.clone().getInUTC());
  freeBusyComponent.updatePropertyWithValue('DTEND', end.clone().getInUTC());
  freeBusyComponent.addProperty(organizer.clone());
  for (const attendee of attendees) {
    const clonedAttendee = attendee.clone();
    clonedAttendee.deleteParameter('ROLE');
    clonedAttendee.deleteParameter('CUTYPE');
    clonedAttendee.deleteParameter('RSVP');
    clonedAttendee.deleteParameter('PARTSTAT');
    clonedAttendee.deleteParameter('REQUEST-STATUS');
    clonedAttendee.deleteParameter('LANGUAGE');
    freeBusyComponent.addProperty(clonedAttendee);
  }
  calendar.addComponent(freeBusyComponent);
  return calendar;
}

export { AbstractComponent, AbstractParser, AbstractRecurringComponent, AbstractValue, AlarmComponent, AttachmentProperty, AttendeeProperty, BinaryValue, CalendarComponent, ConferenceProperty, DateTimeValue, DurationValue, EventComponent, ExpectedICalJSError, FreeBusyComponent, FreeBusyProperty, GeoProperty, ICalendarParser, IllegalValueError, ImageProperty, JournalComponent, ModificationNotAllowedError, Parameter, ParserManager, PeriodValue, Property, RecurValue, RecurrenceManager, RecurringWithoutDtStartError, RelationProperty, RequestStatusProperty, TextProperty, Timezone, TimezoneAdapter, TimezoneComponent, TimezoneManager, ToDoComponent, TriggerProperty, UTCOffsetValue, UnknownICALTypeError, createEvent, createFreeBusyRequest, getConstructorForICALType, getConstructorForPropertyName, getParserManager, getReadableTimezoneName, getSortedTimezoneList, getTimezoneManager, isOlsonTimezone, parseICSAndGetAllOccurrencesBetween, setConfig };
//# sourceMappingURL=index.es.mjs.map
