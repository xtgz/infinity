{"version":3,"file":"index.mjs","sources":["../lib/index.ts"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: GPL-3.0-or-later\n */\n\n/**\n * URI-Encodes a file path but keep the path slashes.\n */\nexport function encodePath(path: string): string {\n    if (!path) {\n        return path\n    }\n\n    return path\n        .split('/')\n        .map(encodeURIComponent)\n        .join('/')\n}\n\n/**\n * Returns the base name of the given path.\n * For example for \"/abc/somefile.txt\" it will return \"somefile.txt\"\n */\nexport function basename(path: string): string {\n    return path\n        .replace(/\\\\/g, '/')\n        .replace(/.*\\//, '')\n}\n\n/**\n * Returns the dir name of the given path.\n * For example for \"/abc/somefile.txt\" it will return \"/abc\"\n */\nexport function dirname(path: string): string {\n    return path\n        .replace(/\\\\/g, '/')\n        .replace(/\\/[^\\/]*$/, '')\n}\n\n/**\n * Join path sections\n */\nexport function joinPaths(...args: string[]) {\n    if (arguments.length < 1) {\n        return ''\n    }\n\n    // discard empty arguments\n    const nonEmptyArgs = args.filter(arg => arg.length > 0)\n    if (nonEmptyArgs.length < 1) {\n        return ''\n    }\n\n    const lastArg = nonEmptyArgs[nonEmptyArgs.length - 1]\n    const leadingSlash = nonEmptyArgs[0].charAt(0) === '/'\n    const trailingSlash = lastArg.charAt(lastArg.length - 1) === '/';\n    const sections = nonEmptyArgs.reduce((acc, section) => acc.concat(section.split('/')), [] as string[])\n\n    let first = !leadingSlash\n    const path = sections.reduce((acc, section) => {\n        if (section === '') {\n            return acc\n        }\n\n        if (first) {\n            first = false\n            return acc + section\n        }\n\n        return acc + '/' + section\n    }, '')\n\n    if (trailingSlash) {\n        // add it back\n        return path + '/'\n    }\n    return path\n}\n\n/**\n * Returns whether the given paths are the same, without\n * leading, trailing or doubled slashes and also removing\n * the dot sections.\n */\nexport function isSamePath(path1: string, path2: string): boolean {\n    const pathSections1 = (path1 || '').split('/').filter(p => p !== '.')\n    const pathSections2 = (path2 || '').split('/').filter(p => p !== '.')\n    path1 = joinPaths.apply(undefined, pathSections1)\n    path2 = joinPaths.apply(undefined, pathSections2)\n\n    return path1 === path2\n}\n"],"names":[],"mappings":"AAQO,SAAS,WAAW,MAAsB;AAC7C,MAAI,CAAC,MAAM;AACA,WAAA;AAAA,EACX;AAEO,SAAA,KACF,MAAM,GAAG,EACT,IAAI,kBAAkB,EACtB,KAAK,GAAG;AACjB;AAMO,SAAS,SAAS,MAAsB;AAC3C,SAAO,KACF,QAAQ,OAAO,GAAG,EAClB,QAAQ,QAAQ,EAAE;AAC3B;AAMO,SAAS,QAAQ,MAAsB;AAC1C,SAAO,KACF,QAAQ,OAAO,GAAG,EAClB,QAAQ,aAAa,EAAE;AAChC;AAKO,SAAS,aAAa,MAAgB;AACrC,MAAA,UAAU,SAAS,GAAG;AACf,WAAA;AAAA,EACX;AAGA,QAAM,eAAe,KAAK,OAAO,CAAO,QAAA,IAAI,SAAS,CAAC;AAClD,MAAA,aAAa,SAAS,GAAG;AAClB,WAAA;AAAA,EACX;AAEA,QAAM,UAAU,aAAa,aAAa,SAAS,CAAC;AACpD,QAAM,eAAe,aAAa,CAAC,EAAE,OAAO,CAAC,MAAM;AACnD,QAAM,gBAAgB,QAAQ,OAAO,QAAQ,SAAS,CAAC,MAAM;AAC7D,QAAM,WAAW,aAAa,OAAO,CAAC,KAAK,YAAY,IAAI,OAAO,QAAQ,MAAM,GAAG,CAAC,GAAG,CAAc,CAAA;AAErG,MAAI,QAAQ,CAAC;AACb,QAAM,OAAO,SAAS,OAAO,CAAC,KAAK,YAAY;AAC3C,QAAI,YAAY,IAAI;AACT,aAAA;AAAA,IACX;AAEA,QAAI,OAAO;AACC,cAAA;AACR,aAAO,MAAM;AAAA,IACjB;AAEA,WAAO,MAAM,MAAM;AAAA,KACpB,EAAE;AAEL,MAAI,eAAe;AAEf,WAAO,OAAO;AAAA,EAClB;AACO,SAAA;AACX;AAOgB,SAAA,WAAW,OAAe,OAAwB;AACxD,QAAA,iBAAiB,SAAS,IAAI,MAAM,GAAG,EAAE,OAAO,CAAK,MAAA,MAAM,GAAG;AAC9D,QAAA,iBAAiB,SAAS,IAAI,MAAM,GAAG,EAAE,OAAO,CAAK,MAAA,MAAM,GAAG;AAC5D,UAAA,UAAU,MAAM,QAAW,aAAa;AACxC,UAAA,UAAU,MAAM,QAAW,aAAa;AAEhD,SAAO,UAAU;AACrB;"}